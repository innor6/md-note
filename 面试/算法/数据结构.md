### 堆

用数组来描述二叉树。

最大堆、最小堆。

结点的索引从1开始（即根结点在A[1]），

对于索引为 i 的结点：

- 父节点：i / 2（下取整）
- 左孩子：2i
- 右孩子：2i + 1

**操作**

以最大堆为例

（注意访问孩子结点时要检查是否越界）

- **调整**（维护最大堆性质）

  `MAX-HEAPIFY(A, i)`：A[i]应该比它的两个孩子结点大，否则与最大的孩子交换，向下递归。

  - 时间复杂度：O(h)

- **建堆**

  对结点 `i = (A.length/2) downto 1` ，调用 `MAX-HEAPIFY(A, i)` 

  - 时间复杂度：n * O(h) = O(nlogn)
  - 更紧确的界：**O(n)！！**（堆中高为 h 的结点最多有 `n / 2^{h+1}` 个）

- **堆排序**

  每次取出堆顶元素（与堆尾结点交换），size--，对A[1]调用`MAX-HEAPIFY`

  - 堆尾元素：i = A.length downto 1
  - 原地排序，每次交换后，size--
  - 时间复杂度：O(nlogn)

##### 应用：优先队列

操作

- **最大值**

  直接返回 A[1]

- **删除**

  A[1] = A[A.size]，对A[1]调用 `MAX-HEAPIFY`

  - 时间复杂度：O(logn)

- **增值**（Increase-Key）

  先对结点增值，然后递归向上调整。

  - 时间复杂度：O(logn)

- **插入**

  加入一个值为-∞的结点到堆尾，然后增值，递归向上调整。