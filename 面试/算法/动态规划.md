# 动态规划

适合使用动态规划的场景：

- 重叠子问题
- 最优子结构（子问题独立）
- 写出递推式（状态转移方程，状态就是递推式中的参数。像归纳法？）
- 确定选择：状态转移时，经常有多个选择，即求dp[n]=max(dp[i]+dp[n-i])时，是从几种 子问题组合 中选择最优值。



**注意**：

- 初始化边界条件
- 弄清dp数组下标的意义：有时数组的大小可能为arr[n+1]，arr[0]是临界条件，而arr[n]才是最终状态。



斜着从对角线向↗遍历：

```c++
for (int offset = 0; offset < n; ++offset) {
    for (int i = 0; i + offset < n; ++i) {
        int j = i + offset;
        dp[i][j] = ...
    }
}
```



### 算法步骤

**自顶向下递归：**

- “全局”变量备忘memo[n]存放解，初始化为非法值，如-1，表示问题还未求解。

- 函数dp(n)
  - 每次先查备忘memo[n]，若问题已求解，则直接返回；
  - 否则根据递推式，递归调用dp(x)求解，存入memo后，返回解。
  - （边界条件也剋放在dp函数的开头）

优点：有时求解dp(n)只需求解一部分子问题，而不必遍历整个问题空间。

缺点：递归调用的时间代价。（问题空间树中的边数量）

备忘有时用map可能更好？因为选择自顶向下是因为可能不用遍历整个空间，而用map也不必存整个空间的答案。



**自底向上迭代：**

数组dp[n]用于存放解，记得初始化，如求最小值时，初始化为最大值。

随后从归纳基础开始不断应用递推式求解，填入dp[i]，最后返回dp[n]。  



### 状态压缩

用于优化空间复杂度（每次求dp[i]时，如果只用到之前的局部数据，如只用到dp[i-1]，则可以不用保存整个数组）

状态空间为二维矩阵时，一般可以压缩成只需要一行数组，但要注意，将新数据填入时，可能会覆盖将来还要用到的旧值，具体方法的解决方法取决于递推式，比如从后往前求解。



### 记得

- 空值的情况。

- 初始化 dp[n] （临界条件）：有时初始化全部，有时只需初始化开头几个元素（即临界条件，例如递推式含中有dp[i-1]时，显然dp[0]要率先初始化，且在迭代中不考虑i=0的情况）。

- 数组的大小有时可能为dp[n+1]：要想清楚它的含义，如arr[0]是临界条件，而arr[n]才是最终状态，则应该定义为dp[n+1]。



### 经典题





##### 最大连续子数组的和

定义状态dp[i]：<u>以num[i]结尾</u>的最大连续子数组的和

（因为要求数组是连续的，如果把dp[i]定义为0~i中的最大连续子数组，则不能保证这个子数组一定与i+1元素连续，因此dp[i+1]无法从dp[i]中推出）

选择：子数组要么是dp[i-1]的子数组+当前数字，要么只有当前数字。

递推式：dp[i] = max( dp[i-1] + num[i], num[i] )

O(n)

连续子数组——区间树？



##### 0-1背包

dp\[i][w] ：考虑前i个物品、背包总容量为w，则可以装下的最大价值。

dp\[i][w] = 

能拿物品 i 的情况：max of ：

- 不拿：dp\[i-1][w]
- 拿：dp\[i-1][w-wt[i]] + value[i]（即考虑背包容量中占用了wt[i]之后，剩下的容量来放前i-1件物品的情况）}

（事实上由于价值是正数，能拿的话肯定拿了的价值更多）

**子集背包**：从n元素集合中，选取部分元素，得到一个子集，使得这个子集满足一定的条件，如：

1. 总和最大：dp定义如上；
2. 总和为某个值W（即必须恰好装满背包）：dp\[i][w]  == (bool)能否放满背包。

```
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= sum; j++) {
        if (j - nums[i - 1] < 0) {
            // 装不下当前物品：背包容量不足，不能装入第 i 个物品
            dp[i][j] = dp[i - 1][j]; 
        } else {
            // 装的下：装入或不装入背包
            dp[i][j] = dp[i - 1][j] || dp[i - 1][j-nums[i-1]];
        }
    }
}
```

##### 完全背包（多重集合）

找零钱：

货币种类`coins = [1, 2, 5]`，货币可以重复使用，凑出`amount`，有多少种找钱方式？

- 定义dp\[i][j]：只使用前 i 种硬币，凑出目标金额 j，有dp\[i][j]种方式。
- 递推关系：（总方法数为：上方+前方）`dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i]];`
  - 只用前 i-1 种硬币的方法数
  - 使用一枚第 i 种的硬币 + 用前 i 种硬币凑出金额 `j - coins[i]` 的方法数

最少需要多少硬币？

- 定义dp[i]：凑出金额 i 所需的最少硬币数
- dp[i] = `1 + min{ dp[i - coins[0]], dp[i - coins[1]], ... }` （选择一枚硬币，加上凑剩下的钱所需的最少硬币数）
- 也可以用回溯，需要从大硬币开始，剪枝优化。



##### 编辑距离

把字符串s1逐渐编辑为s2，可进行插入、删除、替换操作。

定义dp\[i][j]：s1的前i个字符 与 s2的前j个字符 之间的编辑距离。

初始化边界：dp\[0][i] = i、dp\[i][0] = i

```
if s1[i] == s2[j]:
    return dp(i - 1, j - 1)  # 相同，则不需要编辑，跳过
else:
    min(
        dp(i, j - 1) + 1,    # 左边←：插入s2的第j个字符 + s1[i]与s2[j-1]的编辑距离
        dp(i - 1, j) + 1,    # 上边↑：删除s1的第i个字符 + s1[i-1]与s2[j]的编辑距离
        dp(i - 1, j - 1) + 1 # 左上↖：直接将s1[i]替换为s2[j]
    )
```



##### 扔鸡蛋

dp\[i][j]：用 i 个鸡蛋测试 j 层楼所需的次数。

剩下 j 层楼要测试，在 k = 1~j 层楼扔一个鸡蛋：

- 碎了，则用 i-1 个鸡蛋测试剩下的 k-1 层（`dp[i-1][k-1]`）
- 没碎，则用 i 个鸡蛋测试 k 层之上的 j-k 层（`dp[i][j-k]`）

递推：`dp[i][j] = min{ k取1~j | max(dp[i-1][k-1] + 1, dp[i][j-k] + 1)}`

初始条件：dp\[1][k] = k，dp\[k][0] = 0

优化：（二分法求极小值）“k取1~j” 的过程改为 二分查找：因为`dp[i-1][k-1]`随k单调增, `dp[i][j-k]`随k单调减，因此当这两个数值最接近时，他们的最大值最小（极小值）。

另一种思路：

dp\[i][j]：扔 i 次，有 j 个鸡蛋，则最多可以测试的楼高。

扔一次之后，还可以再扔 i-1 次：

- 碎了，还剩 j-1 个鸡蛋，还可以再测试下面的`dp[i-1][j]`层
- 没碎，还剩 j 个鸡蛋，还可以再测试上面的`dp[i-1][j-1]`层

递推式：`dp[i][j] = 1 + dp[i-1][j] + dp[i-1][j-1]` 

初始条件：扔的次数 i 可取的最大值是楼高，dp\[i][1] = i，dp\[1][j] = 1



##### 戳气球

n个气球，每个气球标上数值，戳第k个气球后，获得`nums[k-1]*nums[k]*nums[k+1]`金币，请问最多能获得多少金币。

选择：对于第 i 到第 j 个气球，选择最后一次戳第 i < k < j 个气球，得到

递推关系：`dp[i][j] = num[i]nums[k]nums[j] + dp[i][k] + dp[k][j] ` 

技巧性：这里我们在最外侧加上两个num[i] = 1的哨兵气球。

（类似矩阵链乘法，从对角线dp\[i][i] = 0开始向↗计算；也可以从下往上，从左到右遍历）



##### 套路：子序列问题

注意：下面的三种情况里，两个序列的问题总是用二维数组；一个序列的问题用一维还是二维数组，取决于最优子结构怎么定义，如回文子序列的子问题显然是要缩小前后索引范围（i 和 j），因此用二维数组。

第一种：一维dp数组

##### 最长递增子序列（LIS）

定义状态dp[i]：<u>以第 i 个数字 num[i] 结尾</u>的最长递增子序列LIS的长度，

选择：前 i-1 个LIS中，找末尾数字比 num[i] 小的LIS，则可以在末尾添上num[i]，长度+1。

递推式：dp[i] = max( dp[j] + 1, dp[i] ) | 其中 j 满足 j < i 且 num[j] < num[i]。

遍历：从左到右，每次考察第 i 个元素左边的所有元素。

O(n^2)



第二种：二维dp数组

- 两个字符串：dp\[i][j] 是子串 s1[0~i] 和 s2[0~j] 的 xxx。
- 一个字符串：dp\[i][j] 是子串 s[i~j] 的 xxx。

##### 最长公共子序列（LCS）

dp\[i][j] 定义：子字符串 s1[0~i] 和 s2[0~j] 的最长公共子序列。

选择：对于s1和s2的最后一个字符，看是否相同

1. 相同（s1[i] == s2[j]）：`dp[i][j] = dp[i-1][j-1]`，取↖
2. 不同（s1[i] != s2[j]）：`max( dp[i-1][j], dp[i][j-1] )`，取↑或←的最大值
3. 初始条件：dp\[0][...] = 0，dp\[...][0] = 0

遍历：从上到下，从左到右，每次考察←↖↑三个位置的值，<u>编辑距离、正则表达式匹配</u>也是这种遍历方式。

##### 最长回文子序列

dp\[i][j] 定义：子串s[i~j]的最长回文子序列长度。（注意这里是子序列，不是子串）

选择：看两端的字符是否相同

1. 相同（s[i] == s[j]），形成更长的回文：`dp[i][j] = dp[i+1][j-1] + 2`
2. 不同，则取字串中最长回文：`dp[i][j] = max( dp[i][j-1], dp[i+1][j] )`
3. 初始条件：dp\[i][i] = 1，下三角形全为0（实际只需要用到对角线的下面一斜列）

遍历：从对角线向↗遍历，也可以从下往上，从左到右遍历，每次考察↙←↓三个位置。<u>矩阵链乘法</u>也是这种遍历方式。



##### 博弈问题

对于两人轮流选择的博弈问题，解法：

以{first, second}作为元素（先后手），构建dp数组，选择：

- 先手方进行了某个选择（这里可能需要考察多个选择选最值），给 dp\[i][j].first 赋值
- 后手方接下来的选择，相当于剩余状态下的先手方的选择：dp\[i][j].second = 子问题dp.first

如果这种选择具有最优子结构，就可以用动态规划，自底向上。



##### 区间调度

给定一系列（x轴上的）区间，选出不重叠的区间，求能选取的最大数量。

贪心：将区间按结束时间排序，每次选择一个最早结束、且不与之前选择冲突的区间。

