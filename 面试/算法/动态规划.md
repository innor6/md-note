# 动态规划

适合使用动态规划的场景：

- 重叠子问题
- 最优子结构（子问题独立）
- 写出递推式（状态转移方程，状态就是递推式中的参数。像归纳法？）
- 确定选择：状态转移时，经常有多个选择，即求dp[n]=max(dp[i]+dp[n-i])时，是从几种 子问题组合 中选择最优值。



### 算法步骤

**自顶向下递归：**

“全局”变量备忘memo[n]存放解，初始化为非法值，如-1，表示问题还未求解。

函数dp(n)每次先查备忘memo[n]，若问题已求解，则直接返回；否则根据递推式，递归调用dp(x)求解，存入memo后，返回解。

优点：有时求解dp(n)只需求解一部分子问题，而不必遍历整个问题空间。

缺点：递归调用的时间代价。（问题空间树中的边数量）



**自底向上迭代：**

数组dp[n]用于存放解，记得初始化，如求最小值时，初始化为最大值。

随后从归纳基础开始不断应用递推式求解，填入dp[i]，最后返回dp[n]。  



### 

### 状态压缩

用于优化空间复杂度（每次求dp[i]时，如果只用到之前的局部数据，如只用到dp[i-1]，则可以不用保存整个数组）

状态空间为二维矩阵时，一般可以压缩成只需要一行数组，但要注意，将新数据填入时，可能会覆盖将来还要用到的旧值，具体方法的解决方法取决于递推式，比如从后往前求解。



### 记得

空值的情况。

初始化 dp[n] 的临界条件：有时初始化全部，有时只需初始化开头几个元素（即临界条件，例如递推式含中有dp[i-1]时，显然dp[0]要率先初始化，且在迭代中不考虑i=0的情况）。

数组的大小有时可能为dp[n+1]：要想清楚它的含义，如arr[0]是临界条件，而arr[n]才是最终状态，则应该定义为dp[n+1]。



### 经典题

##### **最长递增子序列**

定义状态dp[i]：<u>以num[i]为结尾</u>的最长递增子序列LIS的长度，

选择：则 num[i] 的 LIS 应该为比 num[i] 小的元素的 LIS末尾添上num[i] 元素。

递推式：dp[i] = max( dp[j] + 1, dp[i] ) | 其中 j 满足 num[j] < num[i]。

O(n^2)



##### **最大连续子数组的和**

定义状态dp[i]：<u>以num[i]结尾</u>的最大连续子数组的和

（因为要求数组是连续的，如果把dp[i]定义为0~i中的最大连续子数组，则不能保证这个子数组一定与i+1元素连续，因此dp[i+1]无法从dp[i]中推出）

选择：子数组要么是dp[i-1]的子数组+当前数字，要么只有当前数字。

递推式：dp[i] = max( dp[i-1] + num[i], num[i] )

O(n)

连续子数组——区间树？



##### **0-1背包**

dp\[i][w] ：要拿第i个物品时，若背包总容量为w，则可以装下的最大价值。

dp\[i][w] = 

能拿的情况：max of ：

- 不拿：dp\[i-1][w]
- 拿：dp\[i-1][w-wt[i]] + value[i]（即考虑背包容量中占用了wt[i]之后，剩下的容量来放前i-1件物品的情况）}

（事实上由于价值是正数，能拿的话肯定拿了的价值更多）

**0-1背包的内涵——子集**：从一个集合中，选取部分元素，得到一个子集，使得这个子集满足一定的条件：

1. 总和最大：dp定义如上；
2. 总和为某个值W：dp\[i][w]  == (bool)能否放满背包。