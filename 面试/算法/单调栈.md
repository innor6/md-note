# 单调栈

[LC 84.柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

**下一个更大元素**：用于找到数组中下一个比当前元素大的元素。

方法：

1. 从后往前扫描数组
2. 每次尝试将当前元素放入栈
3. 放入之前检查，如果栈顶元素 <= 当前元素，弹出栈顶，直至找到第一个大于当前元素的栈顶元素（或栈空），则此元素就是当前元素的**下一个更大元素**。

循环不变式：

- 保证从栈顶到栈底是单调递增的（**栈顶小**，严格递增，相同也不行）

```c++
int n = nums.size();
vector<int> res(n, -1);	//记录nums[i]的下一个更大元素，-1表示不存在
stack<int> s;
for (int i = n - 1; i >= 0; --i) {
	while (!s.empty() && s.top() <= nums[i]) s.pop();	//1.弹出小于、等于当前元素的元素
    if (!s.empty())	res[i] = s.top();	//2.记录：则栈顶剩下的就是当前元素的“下一个更大元素”
    s.push(nums[i]);	//3.放入当前元素
}
```



**技巧性**

要找下一个更大元素，显然要从后面开始扫描，且自栈底到栈顶依次减小，这样弹出时可以从小到大检查。

同理，要找后面第一个比当前元素小的元素，则从后往前扫，栈底最小。

如果要找前一个更大元素，则从前往后扫描。



说明：

其实也可以从前往后扫描

- 使用相同的循环不变式（栈顶小）
- 当要放入的元素 > 栈顶时，说明栈顶元素的“下一个更大元素”就是要放入的元素，记录
- 一直记录、弹出，直到可以保证放入当前元素不会破坏栈的单调性

但是这样做的缺点是，记录的顺序是“乱序”的：因为连续弹出的时候，顺序和入栈的顺序相反，而不连续弹出时，又与入栈的顺序相同。



变体——**循环数组**的**下一个更大元素**

只需把扫描范围变为 2n-1 ~ 0，且下标改为`nums[i % n]`，即可保证每个元素都检查了其“后面”的n个元素。





# 单调队列

[滑动窗口的最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)：类似单调栈，维护一个双端队列，保证从队尾到队头单调递增（队头是最大值）。

1. 每次尝试插入元素到队尾
2. 将队尾比当前元素小的元素都移除
3. 队头就是所有已入队元素中的最大值

维护队列、获取最大值的时间复杂度都为O(1)。（每个元素都入队出队一次）

```c++
deque<int> q;

void push(int i) {
    while (!q.empty() && q.back() < i) 
        q.pop_back();
    q.push_back(i);
}

int max() { return q.front(); }

void pop(int i) {
    if (!q.empty() && q.front() == i)
        q.pop_front();
}

```

