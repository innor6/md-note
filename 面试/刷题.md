[fucking-algorithm](https://github.com/labuladong/fucking-algorithm/blob/master/README.md?utm_source=qq&utm_medium=social)



1. 函数开头先考虑：空值、边界情况
2. 初始化临界条件，如arr[0]
3. 注意数组的大小并不一定是arr[n]，有时可能应该为arr[n+1]，要想清楚它的含义。特别是**动态规划**的时候，arr[0]是临界条件，而arr[n]才是最终状态。



1. 判断奇偶： `(x & 1) == 1` （！！注意：位运算优先级低于关系运算符）

2. 变成偶数： `x & -2`

3. 整数除法除2： `x >> 1`

4. 优雅的遍历vector：

   ```
   for (int i : vec) { //... }
   ```

5. 



常见错误：

heap-buffer-overflow：数组越界访问



##### 单元测试

功能测试、边界测试、错误测试。





##### 考虑特殊情况：

边界条件：循环的特殊值

错误处理

参数的合法性（特殊输入）：参数符合题意，指针为nullptr、指针所指对象是否合法、空字符串、容器size合法、容器内元素值的合法性

无符号数：小心`size_t -1`变为负数

index、指针越界





溢出处理：

- 两个int相加/相乘溢出
  - (a + b) / 2 可改写为 a + (b - a)/2 或 a/2 + b/2

`-2147483648`（int32_min）取绝对值，会超出int32_max。





**数组**：

- 利用随机存取特性，当作hash表用（基数排序）
- 线性表不适合插入，插入一个元素需要大量移动后面元素，可以数组尾部开始移动。



**链表**

- 注意空链表、越界！

- 注意参数有时会传入一个结点的指针的指针（node**，c风格，值-结果参数），说明头节点可能会被删除。

- 删除结点时，要抓住待删除结点的前一个结点。

- 注意头结点、尾结点与其他结点的处理方式不同

- 双指针：遍历链表，可以减少遍历次数。

- 哑结点：new一个哑结点（dummy），使其next为原链表的头结点，则删除头结点的代码变得简单，直接返回`dummy.next`。

  将链表分成三个部分：`pre-> || p->q || ->next`，对中间部分进行操作。



先进后出：栈（**DFS**）

可以利用程序递归调用本身作为栈：先dfs()子结点，再处理当前结点。

逆序打印链表



**分治法**：

if (递归出口) 

​	return 终点值；

else 

​	继续分治；



**回溯/DFS**：

if (根节点) 

​	得到一个解；

else if (当前结点符合约束 && 限界)

​		进一步搜索子节点；

​	

**动态规划**

有时候根据题目限制，初始几个小问题的解，dp子问题最优解的值不同，需要对小规模的子问题特殊考虑。

如：一条绳子分两段，求乘积最大值，则长为3的绳子最优解为2；但当3作为子问题时，其值应该为3，因为此时不需要分两段。



**位运算**

注意：右移操作时，负数的高位添1。

对于`a & mask`，右移a可以转换为左移mask。

unsigned int

一个数减一，与这个数自身做与运算：n & (n-1)，就会把最右边的一个1变为0。

`n>>1`：位运算n/2

`n & 1`：位运算判奇偶 n%2

注意：位运算优先级低于关系运算符，所以`n & 1 == 1`是错误的写法！

