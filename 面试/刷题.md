[fucking-algorithm](https://github.com/labuladong/fucking-algorithm/blob/master/README.md?utm_source=qq&utm_medium=social)



注意

1. 函数开头先考虑：空值、边界情况
2. 初始化临界条件，如arr[0]
3. 注意数组的大小并不一定是arr[n]，有时可能应该为arr[n+1]，要想清楚它的含义。特别是**动态规划**的时候，arr[0]是临界条件，而arr[n]才是最终状态。
4. int 不要直接放到 `string.push_back()` 里，要转换为char：`i + '0'`
5. 输入：只含正数、相加溢出





##### 思路

- 滑动窗口、字符串的排列：想到用多重集合`unordered_map<char,int>`来描述。

- 前缀和：记录数组前k个数字之和，则 `sum[i]-sum[j]` 就是 `[j+1, i]` 区间的数字之和

- 匹配问题通常用到栈：如括号的匹配、接雨水匹配成一个碗等。

- 二分查找：在某个数字范围中找合法的最大值/最小值：

- 原地排序：限制了空间复杂度时，可以考虑在输入数组上进行原地hash。

- 可能溢出：位运算、转换为long long： `1LL * i * i` 、转换为 double

- 链表、树的后序遍历：递归时，后序往往是因为需要先处理子树，然后再把子树拼接当前结点的next



##### 技巧

阶乘表可以提前算好，因为利用递推公式一次性算完，比每次重新算更快。

利用 或操作 处理容器为空的特殊情况：

```c++
// res空的时候，插入
// 或res非空时，则与上一次插入元素不同时插入
if (res.empty() || nums1[i] != res.back()) {	
	res.push_back(nums1[i]);
}
```





**血的教训**

- if-else 一定要用大括号括起来！
- uint和int比较，会全部转换为uint，如：使得 -1 > vec.size() 永远为真！
- 交换操作，可能陷入一直交换这两个位置的死循环



##### 位运算

1. 判断奇偶： `(x & 1) == 1` （位运算 **优先级低于** 关系运算符，所以`n & 1 == 1`是错误的写法）
2. 变成偶数： `x & -2`
3. 整数除法除2： `x >> 1`
4. 与、或、非、异或都有交换律和结合律。
5. *成对的消去相同元素（异或是在每位上单独执行不进位的加法）：`a ^ a = 0` ， `a ^ 0 = a`
6. *将二进制中最右边的 `1` 设置为 `0`：`x & (x - 1)`
7. *只保留二进制中最右边的 `1`，并将其他位设置为 `0`：`x & (-x)`（需要x为正数，原理是-x = x取反+1）
8. 注意：负数进行右移操作时，高位添1。
9. 大小写转换：

   ```
   ('a' | ' ') = 'a'
   ('A' | ' ') = 'a'
   ('b' & '_') = 'B'
   ('B' & '_') = 'B'
   ('d' ^ ' ') = 'D'
   ('D' ^ ' ') = 'd'
   ```

11. 判断是否异号

    ```c
    int x = -1, y = 2;
    bool f = ((x ^ y) < 0); // true
    ```

12. 







1. 取整
   - 下取整：M / N 
   - 上取整： (M+(N-1)) / N

2. 溢出处理：

   - 两个int相加/相乘可能溢出：`(a + b) / 2` 可改写为 `a + (b - a)/2` 

   - `-2147483648`（int32_min）取绝对值，会超出int32_max。

3. m*n矩阵坐标转换：
   - 一维坐标 t（下标从0开始，到m*n-1）
   - 二维坐标
     - `i = t / m`
     - `j = t % n` （每一行下标从0开始，到n-1）
   
4. 区间相交：

   - `lo1 < hi2 && lo2 < hi1`：lo总是低于另一个区间的hi
   - 相交部分为：`[max(lo1,lo2), min(hi1,hi2)]`

5. 取模：

   - `a + b === a' + b' (mod n)`（这里 `a === a' (mod n)`）
   - `a * b === a' * b' (mod n)`

6. 循环数组：

   - `arr[i % n]`

   

##### 语言

1. 优雅的遍历容器vector：

   ```c++
   for (int i : vec) { ... }
   for (auto &i : vec)	{}//如果需要修改i，使用&表示引用，auto在这里是容器中的元素类型
   //注意：不能在range-for中修改容器vec的大小，否则可能导致迭代器失效！！
   ```

2. 清空数组：

   ```c
   #include <cstring>
   int dp[n][n];	//n可以是变量！！
   memset(dp, 0, sizeof(dp));	// 每个字节填0（注意此方法只能填0或-1，因为是按8bit填充的）
   ```
   
   （数组长度n可以是变量，但是数组是分配在栈上的，超过8192B可能栈溢出）
   
3. 数组指针：

   ```c++
   int* arr;
   arr = new int[edges.size()+1];
   ```

4. 多个元素比大小

   ```c
   min({a, b, c, d})	// 初始化列表 <algorithm>
   ```

5. 整型最大值：

   ```c++
   int i = INT_MAX;	//2147483647	<climits>  <cstdint>(这个好像是错的) 
   ```

6. 科学计数法

   ````c
   int a = 25e+9;	// a = 25 * 10^9
   ````

   



##### 类型转换

```
// char - int
'0' + 1 == '1'
++'a' == 'b'
```





##### 运行时错误

heap-buffer-overflow：数组越界访问

段错误：内存访问超出了分配给该程序的内存空间





##### 考虑特殊情况：

边界条件：循环的特殊值

错误处理

参数的合法性（特殊输入）：参数符合题意，指针为nullptr、指针所指对象是否合法、空字符串、容器size合法、容器内元素值的合法性

无符号数：小心`size_t -1`变为负数

index、指针越界





##### 数组

- 利用随机存取特性，当作hash表用（基数排序）
- 线性表不适合插入，插入一个元素需要大量移动后面元素，可以数组尾部开始移动。



##### 链表

- 注意空链表、越界！

- 注意参数有时会传入一个结点的指针的指针（node**，c风格，值-结果参数），说明头节点可能会被删除。

- 删除结点时，要抓住待删除结点的前一个结点。

- 注意头结点、尾结点与其他结点的处理方式不同

- 双指针：遍历链表，可以减少遍历次数。

- 哑结点：new一个**哑结点**（dummy），使其next为原链表的头结点，则删除头结点的代码变得简单，直接返回`dummy.next`。

  将链表分成三个部分：`pre-> || p->q || ->next`，对中间部分进行操作。



先进后出：栈（**DFS**）

可以利用程序递归调用本身作为栈：先dfs()子结点，再处理当前结点。

逆序打印链表



**分治法**：

if (递归出口) 

​	return 终点值；

else 

​	继续分治；



**回溯/DFS**：

if (根节点) 

​	得到一个解；

else if (当前结点符合约束 && 限界)

​		进一步搜索子节点；

​	

**动态规划**

有时候根据题目限制，初始几个小问题的解，dp子问题最优解的值不同，需要对小规模的子问题特殊考虑。

如：一条绳子分两段，求乘积最大值，则长为3的绳子最优解为2；但当3作为子问题时，其值应该为3，因为此时不需要分两段。











**单元测试**

功能测试、边界测试、错误测试。

