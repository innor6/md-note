[TOC]

数据库组成：

查询编译器

执行引擎

索引、记录管理

缓冲区管理

存储器管理（硬盘）

事务、并发、日志、锁表



# 概述

### 基本概念

**数据库**

长期存储、有组织、可共享的大量数据的集合

**数据库模式**

模式（schema）：全体数据的<u>逻辑结构和特征的描述</u>（数据表的语义、表头、元数据），数据库模式是所有关系模式的集合。

关系（relation）：一个规范化的二维表，是一个关系模式的实例。

模式描述数据关系，即一条记录由哪些字段组成、字段的域。

**数据库特点**

- 数据结构化
- 数据的共享性高，冗余度低
- 数据独立性高
- 数据由DBMS统一管理和控制

**数据库系统**

采用了数据库技术的计算机系统（包括数据库、OS、DBMS、应用程序开发工具、应用程序、用户）



### 数据库系统的三个问题

- DBMS的实现
- 数据库结构的设计
- 数据的高效存取

具体展开讲：

**DBMS的实现**

一些关注点：元组在磁盘上的存储、高级查询处理优化、缓冲区管理、并发控制（事务处理）、索引、可靠性、应用程序编程接口（API）、数据字典组织

**数据库结构的设计**

数据冗余
更新异常
插入异常
删除异常

主要问题：到底什么样的数据库模式才合理？怎么分解才能满足要求？标准是什么？如何实现？

**数据的存取问题**

数据定义语言（DDL）
数据操纵语言（DML）
数据库控制语言（DCL）



# 关系数据库

### 数据库体系结构——三级模式，两级映像

模式：数据库的逻辑结构和特征的描述

**三级模式**

- 外模式（view level）——视图
- 概念模式（logical level）——基本表
- 内模式（physical level）——文件

why 3 层？：增加数据库的可维护性能

外模式（用户模式）：

- 单个用户所看到的局部数据的逻辑结构特征
- 建立在概念模式之上

概念模式（逻辑模式）：

- 数据库中全体数据的逻辑结构和特征的描述，即所有表的定义
- 一个数据库只有一个概念模式

内模式（存储模式）：

- 物理结构和存储方式（文件）的描述：存储方式、索引方式、加密、压缩
- 不考虑具体设备的大小（物理块、页、柱面、磁道）
- 一个数据库只有一个内模式

**两级映像**

外模式/模式映像：数据的逻辑独立性（概念模式里属性名改变时，可修改映像，保持外模式不变）

模式/内模式映像：数据的物理独立性（内部存储结构改变时，修改映像，可保持逻辑模式不变）

独立性：修改逻辑模式/内模式，能够保证外模式不变，也就保证了用户程序不用改变。

**数据模型的抽象**：现实世界——概念模型（E-R模型）——结构化的数据模型（数据表）

### 码（★）

- 超码：在关系中能唯一标识一个元组的属性集（可能是多个属性一起，且可以有多余的属性）称为关系模式的超码
- 候选码：不含多余属性的超码（多余指去掉这个属性还是能标识元组）
  - 主属性：包含在候选码中的属性
  - 非主属性：不包含在任何候选码中的属性
- 主码（码）：用户选择一个候选码作为元组的标识，称为主码；其余的候选码称为替换码。

### 关系的性质

关系是一个二维表格（是关系模式的一个实例）

- 属性值不可分解
- 元组不可重复（一个关系模式至少存在一个候选码）
- 没有行序，即元组之间无序
- 没有列序，即属性之间无序

### 函数依赖

Function Dependency

**逻辑蕴含**：如果根据X的值，能唯一确定Y的值（单射），则有函数依赖 X→Y。

**闭包**：被函数依赖集F逻辑蕴含的所有函数依赖的集合称为F的闭包，记做F^+。（即集合F可以推出的所有函数依赖的集合）

**属性的闭包**：指X在通过函数依赖F能够推出的所有属性的集合，记作X^+。（包括X自己，即 X→？右侧所有可以出现的属性的集合）

增广律：若 A→B，则 AC→BC（AC表示A∪C）*

传递律：若 A→B 且 B→C，则 A→C

分解律：若 A→BC，则 A→B 且 A→C

合并律：若 A→B 且 A→C，则 A→BC

复合律：若 A→B 且 C→D，则 AC→BD *

### 最小函数依赖集

- 每个FD的右边只有一个属性
- 每个FD左部不可约（FD左边里的每个属性都不能再删除了）
- F不可约（每个FD不能通过其他几个FD组合推出，类似线性无关？）

**例子：求最小函数依赖**（利用**分解律、增广律**）

1. 所有依赖右边化为单属性，并去重
2. 消除左侧冗余属性
3. 消除冗余的函数依赖
   - 方法：F去掉X→Y后，如果X还能推出Y，则该FD（指X→Y）冗余。（从第一个依赖FD开始，从F中去掉它，假设去掉X→Y，则在剩下的依赖中求X的闭包X+，如果X+还是包含Y，则说明可以去掉该依赖。）
   - 属性X的闭包：指X在通过函数依赖F能够推出的所有属性，包括X自己。

**判断候选码**：

如果一个属性/属性集的闭包包含所有属性，则是它是超码；如果它不含多余的属性，则它是候选码。

**求主码的方法？？**：

先找出所有函数依赖左部的属性，然后消除这些属性间依赖，剩下的一起构成一个主码。

### 关系代数

并、交、差、笛卡尔积、连接

选择（σ，select，对应于WHERE）

投影（π，project，对应于SELECT后面的字段）

重命名（ρ，rename，对应于AS）

### 三类完整性

实体完整性：主码不可为空值

参照完整性：每个外码要么能在另一表中找到唯一的相同值，要么外码为空

用户自定义完整性



# 模式设计

### 设计不规范带来的问题

- 数据冗余
- 更新异常：修改某个值，必须修改多行
- 插入异常：不能插入有部分空值的记录
- 删除异常：删除某行，同时会删除其他信息

### 模式分解

属性集的分解、函数依赖的分解。

分解的标准：

- 具有无损连接：分解后的关系，自然连接后能恢复为原关系
  - **验证无损连接**的方法：分解后，满足FD：R1∩R2 → R1-R2（或R2-R1），如分解为{R1(A,B),R2(A,C)}，有 A → B
- 保持函数依赖：分解后的各关系中的函数依赖闭包，union后可得到原来的函数依赖闭包F+

### 范式

范式越高，模式设计问题越少，但连接运算多，查询效率低，但模式分解到何时才结束？

为了便于分析是第几范式，通常将不可约FD集用函数依赖图画出来。

- 1NF：单个属性不可再分

- 2NF：非主属性都<u>完全依赖</u>于主码，即必须整个主码才能推出非主属性。

  （消除局部依赖：把局部依赖单独做一个表）

- 3NF：非主属性都<u>不传递依赖</u>于主码，即非主属性直接依赖于主码。

  （消除传递依赖：把非主属性和它直接依赖的属性单独做一个表）

2NF、3NF都假设只有一个候选码，即只考虑了FD为（主码→非主属性）的情况，但有时候R可能会有多个候选码，从而需要考虑（主码→主属性、主属性→非主属性）的情况，此时就会出现对主属性但不是候选码“局部依赖”、“传递依赖”。

- BCNF：FD的左端必须都是候选码，而不能只是主属性。

  （把FD左侧的主属性分出一个表，使得主属性在新关系中是候选码）

分解到BCNF不一定能保持函数依赖！

**时间效率和模式设计权衡**：

- 范式越高，模式设计问题越少，但连接运算越多，查询效率越低
- 如果应用对数据**只是查询**，没有更新操作，则非BCNF范式也不会带来实际影响
- 如果应用对数据**更新操作较频繁**，则要考虑高一级范式以避免数据不一致

### 模式分解的三个算法

具体见ppt。

1. 保持函数依赖地分解到3NF

   方法：先求出最小函数依赖集F，不在F中的属性合并为一个关系R’。然后考虑剩下的属性，查看每个FD，左部相同的FD中涉及的属性合并成一个关系R1。如果关系R1的属性是另一个之前生成的关系R0的属性的子集，则去掉R1这个关系。

2. 无损连接且保持函数依赖地分解到3NF

   方法：先用1，然后在加一个只含主码X的关系R(X)，如果这个关系是某个已有关系的子集，则删除这个主码关系，就可以了。

3. 无损连接地分解R到BCNF

   方法：每次从某个关系R中找一个违反BCNF范式（FD左侧不是当前关系的主码）的FD，其涉及的属性合并得到一个关系R1，并从原来的关系R中去掉这个FD右侧的属性。

（其实画出函数依赖图，直接把违反范式的FD单独分解出一个关系就可以了）



# 数据库设计

设计步骤：

- 概念设计：E-R图
- 逻辑设计：关系模式（二维表）
- 物理设计

ER模型

- 实体：一个实体具有唯一标识，即码（key）。
- 联系：1:1，1:N，M:N

ER图符号（见ppt）

矩形：实体

椭圆：实体的属性，主码加下划线

菱形：联系，两端写上基数（1:N, M:N, 1:1）

E-R模型的优化：

- 合并实体类型（1:1联系的两个实体可以合并为一个实体）
- 消除冗余属性
- 消除冗余联系

E-R模型的扩展：

弱实体：依赖于某个实体而存在；实体没了，弱实体也没。

子类：研究生是学生的子类，经理是职工的子类。

##### 基本ER模型转换到关系模型

1. 实体转换
   - 每个实体转换为一个关系模式
2. 联系转换
   - 1:1：将任一端的<u>实体的标识</u>、<u>联系属性</u>加入另一实体所对应的关系模式中
   - 1:N：将1端<u>实体的标识</u>、<u>联系属性</u>加入N端实体所对应的关系模式中
   - M:N：新建一个关系模式，该模式的属性为<u>两端实体的标识</u>以及<u>联系的属性</u>，主码为：两端关系模式的主码的组合
3. 扩展ER模型
   - 弱实体转换：每个弱实体转换为一个关系模式，并加入所依赖的强实体的标识，关系模式的主码为：（弱实体的标识 + 强实体的标识）。
   - 子类转换：子类实体转换为一个关系模式，并在子类关系模式中加入父类的主码，主码设为：父类的主码。



# 存储器

**磁盘**

扇区：磁盘存储的最小单元。

块：OS对磁盘进行数据存取的最小逻辑单元，包含若干个连续扇区。

块地址：物理设备号、柱面号、盘面号（或磁头号）、扇区号

计算：

- 磁盘的容量 = 盘面 * 磁道/盘面 * 扇区/磁道 *字节/扇区

  注：盘面是盘片的两倍，磁道数等于柱面数。

- 位密度 = 磁道容量 / (磁道周长 * 非间隙比例)

- 磁盘旋转一周的时间：7200r/min -> 1000*1/(7200/60)=8.33ms

磁盘的延迟/存取时间：寻道时间 + 旋转延迟 + 传输时间

- 平均寻道时间：启动时间 + 移动过1/3的磁道的时间

- 平均旋转延迟：磁盘旋转半周的时间

- 一个块的传输时间：磁头经过的（扇区+间隙）所占一圈的度数 / 360 * 转一周时间

  如：一圈256个扇区，256个间隙，间隙占10%，则读16个扇区经过的度数为（16/256 * 360 * 90% + 15/256 * 360 * 10% = 22.36度）

**优化：缓冲**

双缓冲处理时间＝R＋nP（P>=R）＝nR＋P（R>=P）

单缓冲处理时间＝n(R + P)

**闪存**

特点：

1. 读快写慢
2. 写前擦除
3. 块擦除次数有限
4. 按页读写（1 page = 2KB）
5. 按块擦除（1 block = 64 pages）



# 数据的表示

数据项包含在记录中，记录存储在块中。

### 数据项的表示

各种数据类型，定长/变长表示

### 记录的组织

记录首部 + 数据

记录首部：记录类型（模式类型）、记录长度、时间戳、其它信息

固定格式：所有记录有相同的逻辑结构。

变长记录：

1. 首部指针法：定长字段在前，变长字段在后。记录首部存储了指向变长字段的指针，第一个变长字段不需要指针。
2. 混合格式：定长+变长，所有字段都是指针，指向真正存储了数据值的地方。

可变格式变长记录：

1. 标记字段（字段的标识、字段的类型、字段的长度）+数据部分
2. Key-Value格式，字段的指针+字段的长度（Redis）

### 记录在块中的组织

记录存放在块中的槽里，块中有一部分空间用于记录槽的使用情况。

记录的地址：rid<块号，槽号>

地址映射表：借助文件系统的逻辑块地址：文件号＋逻辑块地址＋块内偏移（存取时，把逻辑块映射到物理块），好处：删除或移动记录时只要改变映射表项；缺点：映射表空间、映射转换代价。

聚簇：

- 一个块中存储不同类型的记录：把经常一起访问的记录存储在同一块或连续块中，（如当查询经常是需要连接两个关系时，两个关系通过某个相同的键聚簇存储在一起，则查询时避免了连接操作；但是对于其中单个关系的不连接查询会变慢，因为需要读更多的磁盘块。）
- 单关系上的聚簇：将记录按某个字段顺序排列在块中。加快按排序字段查询记录时的效率，利于归并联接。

插入：

当前块放不下时，放到溢出块中，或相邻块中

删除：

若使用删除标记：

1. 若使用偏移表，则可以修改偏移表项指针，将其置空
2. 若使用逻辑－物理地址映射表，则可以将物理地址置空
3. 可以在记录首部预留一开始位：0－未删除，1－已删除

### 块在文件中的组织

堆文件：（无索引）

- 记录不排序，随意存放。

- 插入容易，但查找和删除代价高。

- 类型：链表式堆文件（空闲块链表和满块链表）、目录式堆文件




# 缓冲区管理

缓冲区结构：许多的frame，用于存放block（数据块）

frame参数：脏位、pin-count（引用计数？）、是否加锁

置换算法：LRU、clock、FIFO

不使用OS的缓冲区管理：DBMS需要强制写回磁盘能力（如WAL），OS的缓冲写回一般通过记录写请求来实现（来自不同应用），实际的磁盘修改推迟，因此不能保证写顺序

查询请求record -> 向缓冲区请求frame -> 向磁盘请求page



# 查询优化

### 查询重写

将初始逻辑查询计划转换为优化的逻辑查询计划。

目标：减少查询的开销(I/O次数)

转换规则：

- 减少查询执行时的中间关系大小（元组数）
  - 早做选择（下推选择）
  - 选择合适的连接顺序
- 减少元组的大小
  - 选择之前先投影

### 中间结果的大小估计

T(R)：R的元组数

S(R)：R中每个元组的大小

B(R)：容纳R所有元组所需的块数

V(R, A)：R的属性A上的不同值数，值集的cardinality？

（以上属性保存在数据库中）

**选择：点查询**
$$
T(σ_{a=10} (W))= \frac{T(W)}{V(W,a)}
$$
对于V，V(W,a)=1，假设其他属性的V在选择前后不变。

**选择：反向查询**
$$
T(σ_{a\neq10} (W))= (1-\frac{1}{V(W,a)})T(W)
$$
**选择：范围查询**（假设选中率为1/2或1/3或用范围命中率）
$$
T(σ_{a>10} (W))= \frac{T(W)}{3}
$$
**选择：多个条件AND**（选中率为多个条件的乘积）

**选择：多个条件OR**（选中率用容斥原理算？）

选择后的T值总可以看成是 选中率*T(W)。



**连接：两个关系**
$$
T(X⋈Y)=\frac{T(X)T(Y)}{max\{V(X,a),V(Y,a)\}}
$$
其中a是用于连接X和Y所用的公共属性（外码）

**连接：多个关系连接**
$$
T(W⋈X⋈Y⋈Z)=\frac{T(W)T(X)T(Y)T(Z)}{max\{...\}*...*max\{...\}}
$$
分母为：设W和X有公共属性a和b，则含有分母 max⁡{V(W,a),V(X,a)} 和 max⁡{V(W,b),V(X,b)}；对X和Y、Y和Z做同样处理。

**值集的包含**：连接时，在两个关系中的公共属性a，若V1<V2，则认为V1包含在V2中。连接操作相当于对于R1中的每条记录，去R2中做点查询，能找到T(R2)/V(R2,a)条记录。由此可得上面连接两个关系的计算公式。

**值集的保持**：连接后，只属于单个关系的属性，V不变；属于多个关系的属性，V变为min{V1,V2}。







### 连接代价估计

**嵌套循环连接**

把记录数（块数）少的那个关系R先读满到缓冲区，剩下一个缓冲区块读入另一个关系的全部记录，做连接。

**归并连接**

（假设记录连续存储，即可以以块为单位读入多条记录，但无序）

1. 先对记录归并排序：两趟：
   1. 第一趟：读满缓冲区，对缓冲区内记录排序，形成一个有序的chunck（具有缓冲区大小的块数），写回。
   2. 第二趟：把所有chunk进行k路归并（从k个chunk中各读一块到内存，排序，耗尽后再读入下一块），得到完全排序的记录。（两趟下来每块读2次、写两次）
2. 归并连接：类似2路归并排序的过程，（每块读一次）

每条记录读3次，写2次，共计5次IO。

**索引连接**

（需要连接的字段有索引）

对于R1中的每条记录，通过索引在R2中查找对应记录，找到则读入，做连接。

cost = B(R1) + T(R1) * 选中率（选中率为：T(R2)/V(R2,k)）

**散列连接**

读R1，hash写回桶

读R2，hash写回桶

读R1的一个桶（假设R1的记录比较少），读R2对应的桶（一块一块地读入）做连接。

每块读1次，写回1次，再读1次，共3次。



**比较**：

1. 循环嵌套连接适合规模较小的关系
2. 对于等值连接，若数据无序且不存在索引，则使用hash
3. 排序 + 归并连接适合非等值的连接
4. 已经有序、有索引的，分别使用归并连接和索引连接。





# 事务

### ACID

**Atomicity**：原子性，事务是一个不可分割的操作序列，这些操作要么都做，要么都不做。

**Consistency**：一致性，事务的执行保证数据库从一个一致状态转到另一个一致状态。一致性指满足数据的完整性约束，而事务中可以不满足一致性。（实际上是反过来，一些数据库操作可能会暂时的导致一致性被破坏（那么触发器就会拒绝这样的操作），但是一系列操作的总和完成后，一致性却是满足的，事务存在的意义就是把这些“暂时破坏一致性，但总和的结果又不会破坏一致性”的一系列操作封装成具有原子性的事务。）

**Isolation**：事务并发执行时，相互独立。（只有隔离性是有多种级别的，见下）

**Durability**：事务一旦成功提交，就在数据库永久保存。



### 隔离级别

多个事务并发执行时，可能产生的问题：

1. 脏读：事务B修改了数据a，由于事务未提交，这个修改不具有持久性。如果事务A读取了修改后的值，随后事务B如果rollback，则事务A读到的数据是被B abort的废弃数据。
2. 不可重复读：事务A读数据a，随后事务B修改数据a，并提交，此时事务A再次读数据a，则事务A两次读数据a得到的值不一样了。
3. 幻读：事务A读表a，随后事务B向表a插入/删除一条记录并提交，此时事务A再次读表a，查到的还是原来的记录，而不知道其实已经有记录增加/删除，并且事务A如果插入记录，可能会和B插入的记录出现主键冲突的那个问题。

**隔离级别**：

**未提交读（Read Uncommitted）：**

- 允许事务读任何数据，包括其他事务还未提交的修改。
- 不加锁。
- 脏读、不可重复读、幻读。

**提交读（Read Committed）：**

- 保证不会读到其他未提交事务的修改。
- 修改后加X锁，保持到事务结束。访问数据时加S锁，读出后马上释放S锁。
- 可以防止脏读。

**可重复读（Repeatable Read）：**

- 保证事务重复读同一个数据会读到相同的值（MySQL默认隔离级别）
- 访问数据时加S锁，S锁必须保持到事务结束（防止其他事务修改）。
- 可以防止脏读、不可重复读。

**可串行化（Serializable）：**

- 保证事务调度的是可串行化的。
- 访问数据时加S锁，并保持到事务结束；事务还要锁住访问的整个表。
- 可以防止脏读、不可重复读、幻读。

说明：

1. 从提交读开始，修改数据会加X锁，且保持到事务结束。
2. 隔离级别越高，并发程度越低。

**乐观并发控制**

悲观：加锁。

乐观：假定发生冲突的概率低。不加锁，并发度高。只有当需要更改数据时，才检查是否发生冲突，若发生冲突，则rollback事务。

检查冲突的方法：如检查时间戳/版本，数据有一个时间戳列，数据增删改时更新时间戳。读取数据时得到时间戳，修改时数据时，检查`WHERE timestamp <= old timestamp`



### 日志

**事务的状态**：

\<Start T>、\<Commit T>、\<Abort T>

**事务的原语**：

Input(x)、Output(x)、Read(x,t)、Write(x,t)

前两个是将磁盘中的记录读到buffer，属于IO；后两个是对buffer中的记录进行读写。

先写日志（WAL）：总是先把内存中的日志写到磁盘，再把数据写到磁盘。（即在Write之前，先Flush Log）



undo日志：
- 日志中记录旧值<T,x,v>。
- 立即更新：把数据（新值）全部写回到磁盘后，**再commit**到日志。
- 恢复时，如果事务T的日志里有commit，就说明数据一定都写回到磁盘了，不用处理；而如果**没有commit，则执行undo**。
（新值与旧值：因为log中只有旧值，如果“先commit，再把新数据写入磁盘”，若在commit之后发生故障，这新值就丢失了）

redo日志：
- 日志中记录新值<T,x,v>。
- 延迟更新：把新值写回到磁盘之前，**先commit**。
- 恢复时，如果**有commit，执行redo**；否则，磁盘中存的是旧值，**abort**事务。

undo/redo日志：

- 日志记录新值和旧值：<T,x,v,w>。
- 可以立即更新，也可以延迟更新。
- 但恢复时由于不知道采用了什么更新策略，undo/redo都要做。
  - 先正向扫描日志，将commit的事务放入redo列表，没有commit的放入undo列表。
  - 反向扫描日志，若日志对应的事务在undo列表中，则执行 undo；
  - 正向扫描日志，若日志对应的事务在redo列表中，则执行 redo；
  - 最后对于undo列表中的T，写入<T, abort>。（先undo再redo是为了防止undo把redo的数据给撤销掉）

更新策略比较：

- 立即更新：乐观策略，认为failure几乎不发生。数据立即写回，占用更少的buffer；但是如果发生故障，恢复时数据改回旧值，需要多一次IO。
- 延迟更新：数据延迟写回，占用更多的内存buffer；不论是否进行恢复，数据最多写回一次，IO次数少。



检查点：随着时间推移，恢复需要的redo列表会越来越大，而undo列表的大小则受到并发量的控制，不会变大。如果采取redo策略，使用检查点可以降低恢复时间。  



# 并发事务

读写三大问题：

丢失更新
脏读：写了但没有持久化
不一致分析（汇总）

### 可串行化

串行化的事务调度（T1,T2,T3...）必然能保证数据库的一致性，如果存在一个串行调度的执行效果等价于某个并发调度S，则称S是可串行化的。

我们可以把串行序列用并发调度S安全地执行，以提升性能。

### 冲突可串行化

对于任何一个并发调度序列，如果它可以通过一系列<u>相邻动作</u>的<u>不冲突交换</u>，使其转化为一个形如T1,T2,T3...的串行调度，则称这个调度是冲突可串行化的，这两个调度冲突等价。

（注意：冲突可串行化的调度一定可串行化，反之不成立）

**冲突的交换**：

如果两个动作

1. 同时对同一个数据操作，
2. 至少有一个写操作，

则称这两个动作是冲突的（即RW，WR，WW），交换执行顺序会导致不一致。

例子：事务T1和T2有操作R1(A)W2(A)，则不能交换这两个操作，否则T1读到的A的值会发生变化，说明两个操作序列是不等价的。

**优先图**：（用于判断可冲突串行化）

对于一个调度，通过寻找其冲突操作，得到事务的先后顺序，构造一个有向的优先图，如果优先图无环，则该调度是可冲突串行化的。  



# 封锁调度

实际上实现的是冲突可串行化。

获得的是数据X的锁。

两种操作：l封锁，u解锁。



### 两阶段封锁协议（2PL）

- 对于每个事务，所有封锁都必须在解锁之前。
- 保证了调度是冲突可串行化的。
- 判断串行序列：一个并发序列中，谁的解锁u先执行，则谁在串行序列的前边。
- 有死锁风险。
  （下面除了树协议，其他的锁都要求2PL）



### 共享锁和排他锁（SX）

sl赋予读权限，xl赋予写权限，提高并发性。

1. 要写必须有xl，要读必须有xl或sl；xl只能上一个，sl可以上多个。
2. 2PL：封锁必须在解锁之前
3. 同一数据上xl和sl不能共存（但是对于单个事务，则可以即上sl又上xl，升级？）



**相容性矩阵**

用于判断上某个锁的数据，是否还能再上其他锁。

行是已上的锁，列是将要上的锁，若对应值为“是”，则可以上对应列的锁。

注意：相容性矩阵中的“否”只对<u>来自两个不同事务</u>的锁有效。



### 更新锁（U）

原因：不加区别得将sl升级为xl锁可能引入更加严重的死锁（如两个事务都为sl(X)xl(X)，如果都获得了sl，则会在尝试获取xl时发生死锁），使用更新锁ul可以避免这种问题。

注意：升级的意思是先加锁sl_i(X)，之后加锁xl_i(X)，升级时需要检查相容性，而不是直接“升级”。

SXU协议：

1. ul赋予读权限，并且稍后可以升级为xl。
2. sl不能升级。
3. ul的相容性：申请时像sl，持有时像xl。（数据上有sl时可以加ul锁，但一旦加了ul，不能再加其他任何锁）



### 增量锁（I）

增量操作：INC_i(X)，多个事务同时给数据X增量，增量的执行顺序是无所谓的。但增量与读/写冲突，不能交换顺序。

1. 增量锁只赋予增量权限，而不能读/写。
2. X上可以同时有多个il，但一旦有il，就不能加sl或xl。
3. INC_i(X)与Rj(X)和Wj(X)冲突（i!=j）。



### 多粒度锁（树结构）

用于树状结构的数据。

**警示锁**：

要加S或X时，从根结点开始加锁：

1. 如果实际要加锁的结点在当前结点之下，则给当前结点加警示锁IS或IX（I表示意向）
2. 如果当前结点就是要加锁的结点，则加普通锁S或X。

**使用场景——解决幻像问题**：

普通加锁时，只对已有数据加锁，而后加入的数据没有被上锁，可能被其他事务修改。使用多粒度锁，在后加入数据时，看成是对整个关系的一次写操作，即对关系加X锁，可以解决这个问题。



**树协议**

用于B+树这种结点之间非包含关系，但是想达到子结点又必须读父结点的结构。

观察：对于B+树结构，使用SXU锁，或者2PL都会导致无法并发。

只使用一种锁l：

1. 事务的第一个锁可以加在树的任何位置
2. 事务只有在父结点持有锁的情况下，才能给它的子结点加锁
3. 结点可以在任何时候解锁
4. 事务不能对一个已经解锁的结点再次上锁
   （即加锁只能向下单向延伸）  