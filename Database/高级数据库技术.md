[TOC]

# 概述

### 基本概念

**数据库**

长期存储、有组织、可共享的大量数据的集合

**数据库模式**

模式（schema）：全体数据的逻辑结构和特征的描述关系（数据表的表头）

关系（relation）：一个规范化的二维表

模式描述数据关系，即一条记录由哪些字段组成。

**数据库特点**

- 数据结构化
- 数据的共享性高，冗余度低
- 数据独立性高
- 数据由DBMS统一管理和控制

**数据库系统**

采用了数据库技术的计算机系统（包括数据库、OS、DBMS、应用程序开发工具、应用程序、用户）



### 数据库系统的三个问题

- DBMS的实现
- 数据库结构的设计
- 数据的高效存取

具体展开讲：

**DBMS的实现**

一些关注点：元组在磁盘上的存储、高级查询处理优化、缓冲区管理、并发控制（事务处理）、索引、可靠性、应用程序编程接口（API）、数据字典组织

**数据库结构的设计**

数据冗余
更新异常
插入异常
删除异常

主要问题：到底什么样的数据库模式才合理？怎么分解才能满足要求？标准是什么？如何实现？

**数据的存取问题**

数据定义语言（DDL）
数据操纵语言（DML）
数据库控制语言（DCL）



# 关系数据库

### 数据库体系结构——三级模式，两级映像

模式：数据库的逻辑结构特征

**三级模式**

- 外模式（view level）——视图
- 概念模式（logical level）——基本表
- 内模式（physical level）——文件

why 3 层？：增加数据库的可维护性能

概念模式（逻辑模式）：

- 数据库中全体数据的逻辑结构和特征的描述，即所有表的定义
- 一个数据库只有一个概念模式

外模式（用户模式）：

- 单个用户所看到的局部数据的逻辑结构特征
- 建立在概念模式之上

内模式（存储模式）：

- 物理结构和存储方式（文件）的描述：存储方式、索引方式、加密、压缩
- 不考虑具体设备的大小

**两级映像**

外模式/模式映像：数据的逻辑独立性（概念模式里属性名改变时，可修改映像，保持外模式不变）

模式/内模式映像：数据的物理独立性（内部存储结构改变时，修改映像，可保持逻辑模式不变）

独立性：修改逻辑模式/内模式，能够保证外模式不变，也就保证了用户程序不用改变。

**数据模型的抽象**：现实世界——概念模型（E-R模型）——数据模型（数据表）

### 码

- 超码：在关系中能唯一标识一个元组的属性集（可能是多个属性一起）称为关系模式的超码
- 候选码：不含多余属性的超码（多余指去掉这个属性还是能标识元组）
  - 主属性：包含在候选码中的属性
  - 非主属性：不包含在任何候选码中的属性
- 主码（码）：用户选择一个候选码作为元组的标识，称为主码，其余的候选码称为替换码(Alternate Key)

### 关系的性质

关系是一个二维表格（是关系模式的一个实例）

- 属性值不可分解
- 元组不可重复（一个关系模式至少存在一个候选码）
- 没有行序，即元组之间无序
- 没有列序，即属性之间无序

### 函数依赖

如果根据X的值，能唯一确定Y的值（单射），则有函数依赖 X→Y。

闭包：被函数依赖集F逻辑蕴含的所有函数依赖的集合称为F的闭包，记做F+。

属性的闭包：指X在通过函数依赖F能够推出的所有属性的集合X+，包括X自己，即 X→？右侧所有可以出现的属性的集合。

增广律：若 A→B，则 AC→BC（AC表示A∪C）

传递律：若 A→B 且 B→C，则 A→C

分解律：若 A→BC，则 A→B 且 A→C

合并律：若 A→B 且 A→C，则 A→BC

符合律：若 A→B 且 C→D，则 AC→BD

### 最小函数依赖集

- 每个FD的右边只有一个属性
- 每个FD左部不可约（FD左边里的每个属性都不能再删除了）
- F不可约（每个FD不能通过其他几个FD组合推出，类似线性最小化？）

**例子：求最小函数依赖**（利用**分解律、增广律**）

1. 所有依赖右边化为单属性，并去重
2. 消除左侧冗余属性
3. 消除冗余的函数依赖
   - 方法：F去掉X→Y后，如果X还能推出Y，则该FD（指X→Y）冗余。（从第一个依赖FD开始，从F中去掉它，假设去掉X→Y，则在剩下的依赖中求X的闭包X+，如果X+还是包含Y，则说明可以去掉该依赖。）
   - 属性X的闭包：指X在通过函数依赖F能够推出的所有属性，包括X自己。

**判断候选码**：

对某个属性/属性集，求它的闭包，如果闭包包含所有属性，则是候选码。

**求主码的方法？？**：

先找出所有函数依赖左部的属性，然后消除这些属性间依赖，剩下的一起构成一个主码。

### 关系代数

并、交、差、笛卡尔积、连接

选择（σ，select，对应于WHERE）

投影（π，project，对应于SELECT后面的字段）

重命名（ρ，rename，对应于AS）

### 三类完整性

实体完整性：主码不可为空值

参照完整性：每个非空外码都能在另一表中找到唯一的相同值

用户自定义完整性



# 模式设计

### 设计不规范带来的问题

- 数据冗余
- 更新异常：修改某个值，必须修改多行
- 插入异常：不能插入有部分空值的记录
- 删除异常：删除某行，同时会删除其他信息

### 模式分解

属性集的分解、函数依赖的分解。

分解的标准：

- 具有无损连接：分解后的关系，自然连接后能恢复为原关系
  - 验证无损连接的方法：满足函数依赖 R1∩R2 → R1-R2（或交换R1 R2）
- 保持函数依赖：分解后的各关系中的函数依赖闭包，union后可得到原来的函数依赖闭包F+

### 范式

范式越高，模式设计问题越少，但连接运算多，查询效率低，但模式分解到何时才结束？

为了便于分析是第几范式，通常将不可约FD集用函数依赖图画出来。

- 1NF：单个属性不可再分

- 2NF：非主属性都<u>完全依赖</u>于主码，即必须整个主码才能推出非主属性。

  （消除局部依赖：把局部依赖单独做一个表）

- 3NF：非主属性都<u>不传递依赖</u>于主码，即非主属性直接依赖与主码。

  （消除传递依赖：把传递依赖单独做一个表）

2NF、3NF都只考虑了FD为（主码→非主属性）的情况，而没考虑（非主属性→主属性、主码→主属性）的函数依赖（有多个候选码时会出现）。

- BCNF：FD的左端必须都是候选码（按照函数依赖来分解）

分解到BCNF不一定能保持函数依赖！

**时间效率和模式设计权衡**：

- 范式越高，模式设计问题越少，但连接运算越多，查询效率越低
- 如果应用对数据只是查询，没有更新操作，则非BCNF范式也不会带来实际影响
- 如果应用对数据更新操作较频繁，则要考虑高一级范式以避免数据不一致

### 模式分解的三个算法

具体见ppt。

1. 保持函数依赖地分解到3NF

   方法：先求最小函数依赖集F，不在F中的属性合并为一个关系，然后查看每个FD，左部相同的FD中涉及的属性合并成一个关系。

2. 无损连接且保持函数依赖地分解到3NF

   方法：先用1，然后在加一个只含主码的关系，如果这个关系是某个已有关系的子集，则删除这个主码关系，就可以了。

3. 无损连接地分解R到BCNF

   方法：每次找一个违反范式的FD，其涉及的属性合并得到一个关系。从原来的关系中去掉这个FD右侧的属性。

（其实画出函数依赖图，直接把违反范式的FD单独分解出一个关系就可以了）



# 数据库设计

设计步骤：

- 概念设计：E-R图
- 逻辑设计：关系模式（二维表）
- 物理设计

ER模型

- 实体：一个实体具有唯一标识，即码（key）。
- 联系：1:1，1:N，M:N

ER图符号（见ppt）

矩形：实体

椭圆：实体的属性，主码加下划线

菱形：联系，两端写上基数（1:N, M:N, 1:1）

E-R模型的优化：

- 合并实体类型
- 消除冗余属性
- 消除冗余联系

E-R模型的扩展：

弱实体：依赖于某个实体而存在；实体没了，弱实体也没。

子类：研究生是学生的子类，经理是职工的子类。



# 存储器

**磁盘**

扇区：磁盘存储的最小单元。

块：OS对磁盘进行数据存取的最小逻辑单元，包含若干个连续扇区。

块地址：物理设备号、柱面号、盘面号（或磁头号）、扇区号

计算：

- 磁盘的容量 = 盘面 * 磁道/盘面 * 扇区/磁道 *字节/扇区

  注：盘面是盘片的两倍，磁道数等于柱面数。

- 位密度 = 磁道容量 / (磁道周长 * 非间隙比例)

- 磁盘旋转一周的时间：7200r/min -> 1000*1/(7200/60)=8.33ms

磁盘的延迟/存取时间：寻道时间 + 旋转延迟 + 传输时间

- 一个块的传输时间：磁头经过的（扇区+间隙）所占一圈的度数 / 360 * 转一周时间

  如：一圈256个扇区，256个间隙，间隙占10%，则度数为（16/256 * 360 * 90% + 15/256 * 360 * 10% = 22.36度）

- 平均寻道时间：启动时间 + 移动过1/3的磁道的时间

- 平均旋转延迟：磁盘旋转半周的时间

**闪存**

特点：

1. 读快写慢
2. 写前擦除
3. 块擦除次数有限
4. 按页读写（1 page = 2KB）
5. 按块擦除（1 block = 64 pages）



# 数据的表示

数据项包含在记录中，记录存储在块中。

### 数据项的表示

各种数据类型，定长/变长表示

### 记录的组织

固定格式定长记录：考虑寻址特点，记录和字段的开始地址必须是4的倍数

变长记录：

1. 首部指针法：定长字段在前，变长字段在后。记录首部存储了指向变长字段的指针，第一个变长字段不需要指针。
2. 混合格式：记录中全是指针，指向存储了数据值的地方。

记录首部（Head）：记录类型（模式类型）、记录长度、时间戳、其它信息

可变格式变长记录：

1. 标记字段（字段的标识、字段的类型、字段的长度）+数据部分
2. Key-Value格式，字段的指针+字段的长度（Redis）

### 记录在块中的组织

记录存放在块中的槽里，块中有一部分空间用于记录槽的使用情况。

记录的地址：rid<块号，槽号>

借助文件系统的逻辑块地址：文件号＋逻辑块地址＋块内偏移（存取时，把逻辑块映射到物理块），好处：删除或移动记录时只要改变映射表项

聚簇

插入：

当前块放不下时，放到溢出块中，或相邻块中

删除：

若使用删除标记：

1. 若使用偏移表，则可以修改偏移表项指针，将其置空
2. 若使用逻辑－物理地址映射表，则可以将物理地址置空
3. 可以在记录首部预留一开始位：0－未删除，1－已删除

### 块在文件中的组织

堆文件：（无索引）

记录不排序，随意存放。

插入容易，但查找和删除代价高。

类型：链表式堆文件、目录式堆文件



# 缓冲区管理





# 查询优化

### 中间结果的大小估计

**连接：两个关系**
$$
T(X⋈Y)=\frac{T(X)T(Y)}{max\{V(X,a),V(Y,a)\}}
$$
其中a是用于连接X和Y所用的公共属性（外码）

**连接：多个关系连接**
$$
T(W⋈X⋈Y⋈Z)=\frac{T(W)T(X)T(Y)T(Z)}{max\{...\}*...*max\{...\}}
$$
分母为：设W和X有公共属性a和b，则含有分母 max⁡{V(W,a),V(X,a)} 和 max⁡{V(W,b),V(X,b)}；对X和Y、Y和Z做同样处理。



**值集的保持**：连接后，只属于单个关系的属性，V不变；属于多个关系的属性，V变为min{V1,V2}。

**值集的包含**：连接时，在两个关系中的公共属性a，若V1<V2，则认为V1包含在V2中。连接操作相当于对于R1中的每个值，去R2中点查询，能找到T(R2)/V(R2,a)条记录。由此可得上面连接两个关系的计算公式。



**选择：点查询**
$$
T(σ_{a=10} (W))= \frac{T(W)}{V(W,a)}
$$
对于V，V(W,a)=1，假设其他属性的V在选择前后不变。

**选择：反向查询**
$$
T(σ_{a\neq10} (W))= (1-\frac{1}{V(W,a)})T(W)
$$
**选择：范围查询**（假设选中率为1/2或1/3或用范围命中率）
$$
T(σ_{a>10} (W))= \frac{T(W)}{3}
$$
**选择：多个条件AND**（选中率为多个条件的乘积）

**选择：多个条件OR**（选中率用容斥原理算？）

选择后的T值总可以看成是 选中率*T(W)。





### 连接代价估计

**嵌套循环连接**：

把数量少的那个关系R先读满到缓冲区，剩下一个缓冲区块读入另一个关系的记录，做连接。
**归并连接**：

（假设记录连续存储，即可以以块为单位读入多条记录，但无序）

1. 先对记录排序：两趟：
   1. 第一趟：读满缓冲区，对缓冲区内记录排序，形成一个有序的chunck，写回。
   2. 第二趟：把所有chunk进行k路归并，得到完全排序的记录。（两趟下来每块读2次、写两次）
2. 归并连接：类似2路归并排序的过程，（每块读取/写一次）



# 事务

### 事务的ACID性质

**Atomicity**：原子性，事务是一个不可分割的操作序列，这些操作要么都做，要么都不做。

**Consistency**：一致性，事务的执行保证数据库从一个一致状态转到另一个一致状态。一致性指满足数据的完整性约束，而事务中可以不满足一致性。（实际上是反过来，一些数据库操作可能会暂时的导致一致性被破坏（那么触发器就会拒绝这样的操作），但是一系列操作的总和完成后，一致性却是满足的，事务存在的意义就是把这些“暂时破坏一致性，但总和的结果又不会破坏一致性”的一系列操作封装成具有原子性的事务。）

**Isolation**：事务并发执行时，相互独立。（只有隔离性是有多种程度的）

**Durability**：事务一旦成功提交，就在数据库永久保存。



**事务的状态**：

<Start T>、<Commit T>、<Abort T>

**事务的原语**：

Input(x)、Output(x)、Read(x,t)、Write(x,t)

前两个是将磁盘中的记录读到buffer，属于IO；后两个是对buffer中的记录进行读写。



undo日志：
- 日志中记录旧值<T,x,v>。
- 立即更新：把数据（新值）全部写回到磁盘后，再commit。
- 恢复时，如果事务T的日志里有commit，就说明数据一定都写回到磁盘了，不用处理；而如果没有commit，则执行undo。
（新值与旧值：因为log中只有旧值，如果“先commit，再把新数据写入磁盘”，若在commit之后发生故障，这新值就丢失了）

redo日志：
- 日志中记录新值<T,x,v>。
- 延迟更新：把新值写回到磁盘之前，先commit（WAL，先写日志）。
- 恢复时，如果有commit，执行redo；否则，磁盘中存的是旧值，abort事务。

undo/redo日志：

- 日志记录新值和旧值：<T,x,v,w>。
- 可以立即更新，也可以延迟更新。
- 但恢复时由于不知道采用了什么更新策略，undo/redo都要做。
  - 先正向扫描日志，将commit的事务放入redo列表，没有commit的放入undo列表。
  - 反向扫描日志，若日志对应的事务在undo列表中，则执行 undo；
  - 正向扫描日志，若日志对应的事务在redo列表中，则执行 redo；
  - 最后对于undo列表中的T，写入<T, abort>。（先undo再redo是为了防止undo把redo的数据给撤销掉）

更新策略比较：

- 立即更新：乐观策略，认为failure几乎不发生。数据立即写回，占用更少的buffer；但是如果发生故障，恢复时数据改回旧值，需要多一次IO。
- 延迟更新：数据延迟写回，占用更多的内存buffer；不论是否进行恢复，数据最多写回一次，IO次数少。



检查点：随着时间推移，恢复需要的redo列表会越来越大，而undo列表的大小则受到并发量的控制，不会变大。如果采取redo策略，使用检查点可以降低恢复时间。  



# 并发事务

读写三大问题：

丢失更新
脏读：写了但没有持久化
不一致分析（汇总）

### 可串行化

串行化的事务调度（T1,T2,T3...）必然能保证数据库的一致性，如果存在一个串行调度的执行效果等价于某个并发调度S，则称S是可串行化的。

我们可以把串行序列用并发调度S安全地执行，以提升性能。

### 冲突可串行化

对于任何一个并发调度序列，如果它可以通过一系列<u>相邻动作</u>的<u>不冲突交换</u>，使其转化为一个形如T1,T2,T3...的串行调度，则称这个调度是冲突可串行化的，这两个调度冲突等价。

（注意：冲突可串行化的调度一定可串行化，反之不成立）

**冲突的交换**：

如果两个动作

1. 同时对同一个数据操作，
2. 至少有一个写操作，

则这两个动作是冲突的（即RW，WR，WW），交换执行顺序会导致不一致。

例子：事务T1和T2有操作R1(A)W2(A)，则不能交换这两个操作，否则T1读到的A的值会发生变化，说明两个操作序列是不等价的。

**优先图**：（用于判断可冲突串行化）

对于一个调度，通过寻找其冲突操作，得到事务的先后顺序，构造一个有向的优先图，如果优先图无环，则该调度是可冲突串行化的。  



# 封锁调度

实际上实现的是冲突可串行化。

获得的是数据X的锁。

两种操作：l封锁，u解锁。



### 两阶段封锁（2PL）

- 对于每个事务，所有封锁都必须在解锁之前。
- 保证了调度是冲突可串行化的。
- 判断串行序列：一个并发序列中，谁的解锁u先执行，则谁在串行序列的前边。
- 有死锁风险。
  （下面除了树协议，其他的锁都要求2PL）



### 共享锁和排他锁（SX）

sl赋予读权限，xl赋予写权限，提高并发性。

1. 要写必须有xl，要读必须有xl或sl；xl只能上一个，sl可以上多个。
2. 2PL：封锁必须在解锁之前
3. 同一数据上xl和sl不能共存（但是对于单个事务，则可以即上sl又上xl，升级？）



**相容性矩阵**

用于判断上某个锁的数据，是否还能再上其他锁。

行是已上的锁，列是将要上的锁，若对应值为“是”，则可以上对应列的锁。

注意：相容性矩阵中的“否”只对<u>来自两个不同事务</u>的锁有效。



### 更新锁（U）

原因：不加区别得将sl升级为xl锁可能引入更加严重的死锁（如两个事务都为sl(X)xl(X)，如果都获得了sl，则会在尝试获取xl时发生死锁），使用更新锁ul可以避免这种问题。

注意：升级的意思是先加锁sl_i(X)，之后加锁xl_i(X)，升级时需要检查相容性，而不是直接“升级”。

SXU协议：

1. ul赋予读权限，并且稍后可以升级为xl。
2. sl不能升级。
3. 相容性：申请时像sl，持有时像xl。（数据上有sl时可以加ul锁，但一旦加了ul，不能再加其他任何锁）



### 增量锁（I）

增量操作：INC_i(X)，多个事务同时给数据X增量，增量的执行顺序是无所谓的。但增量与读/写冲突，不能交换顺序。

1. 增量锁只赋予增量权限，而不能读/写。
2. X上可以同时有多个il，但一旦有il，就不能加sl或xl。
3. INC_i(X)与Rj(X)和Wj(X)冲突（i!=j）。



### 多粒度锁（树结构）

用于树状结构的数据。

**警示锁**：

要加S或X时，从根结点开始加锁：

1. 如果实际要加锁的结点在当前结点之下，则给当前结点加警示锁IS或IX（I表示意向）
2. 如果当前结点就是要加锁的结点，则加普通锁S或X。

**使用场景——解决幻像问题**：

普通加锁时，只对已有数据加锁，而后加入的数据没有被上锁，可能被其他事务修改。使用多粒度锁，在后加入数据时，看成是对整个关系的一次写操作，即对关系加X锁，可以解决这个问题。



**树协议**

用于B+树这种结点之间非包含关系，但是想达到子结点又必须读父结点的结构。

观察：对于B+树结构，使用SXU锁，或者2PL都会导致无法并发。

只使用一种锁l：

1. 事务的第一个锁可以加在树的任何位置
2. 事务只有在父结点持有锁的情况下，才能给它的子结点加锁
3. 结点可以在任何时候解锁
4. 事务不能对一个已经解锁的结点再次上锁
   （即加锁只能向下单向延伸）  