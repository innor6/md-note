索引的作用：加速在一个或多个属性上对特定值的查询。

只查看所有可能记录的一小部分，就能找到所需记录。

建立索引的字段称为查找键。



### 索引类型

稠密索引：一个key对应一条记录

稀疏索引：只能用于顺序文件

多级索引：维护复杂，二级以上必须是稀疏索引

辅助索引：对非主键的索引

辅助索引的间接层：

- 结构：索引-桶（间接层）-记录块
- 间接桶中只有指向记录的指针
- 使用间接层可以避免稠密索引本身含有许多重复的键值
- 多值查询时，通过多个辅助索引（间接层）得到多个记录块的指针范围，求交集可以缩小I/O查询范围。

倒排索引：基于关键字的文档检索。关键字索引指向一个只含该关键字的间接桶，间接桶中不只有指向记录的指针，还包含其他信息，如该关键字在文档中出现的位置。多关键字查询时可以指针求交。





# 常用索引结构

用于外存的查询。

## B+树

多叉、有序、平衡树

本质上是文件系统的中的多级索引

- 数据有序，查找快（由于不是二叉树而是多叉，树高不超过三层）
- 支持范围查询（key有序 + 叶结点有一指针指向兄弟结点）
- 更新代价高（结点的合并/分裂递归影响上层）
- 查询次数：树的层数 + 1次访问数据块

细节：

每个结点n个key，n+1个指针。

键值K是它右子树中的最小键值（最左的叶节点）。

一个结点就是一个块，设一个块有1000个key，则三层就可以索引1G条记录。

叶结点的指针指向存储key对应记录的数据块，还有一个指向兄弟结点的指针（用于范围查询）。

充满度：

- 根结点：至少两个指针有效；
- 内部结点：至少一半指针（上取整）；
- 叶结点：至少一半指针（下取整）/至少一半结点有效（上取整）

#### 查找

键K左边的指针指向的块中的key<K，右边指针的块中的key≥K。

#### 插入

当结点中key数量超过n，分裂

- 分裂成两个结点，左边的key数目可能比右边多1；
- 父结点插入一个新的key
- 对于内部结点，分裂时，最中间的key不出现在这一层，直接提到父结点。

#### 删除

如果删除后，key的充满度小于最小充满度

- 若左/右结点可借：借一个key和指针（key值要修改），并修改父结点的key值
- 若左右结点都不可借：则合并两结点，父结点删去一个key

注意：

1. 这里的左右结点是指兄弟结点，必须拥有相同的父结点
2. 如删除的key是父/祖先结点中最小的key，则应该修改这些键值，虽然不修改其实不影响查询

有些实现在删除后不做任何处理，有些实现在在删除处留下删除标记。



## Hash表

用hash函数把key散列到多个桶中。

- 数据无序，只能点查询，不支持范围查询
- 选择一个均匀划分的hash函数较困难
- 查询只需一次I/O，插入删除只需两次I/O，比B+树好得多

细节：

一个桶就是一个块，放多个记录。

如果桶满了，则给桶加一个溢出块。

在桶中查找是线性查找的。



### 动态散列表

（更多见ppt）

#### 可扩展散列表

一个桶数组，里面是指向桶的指针，多个指针可能指向同一个桶。

键值用二进制表示，选择前 i 位作为桶的标号；

根据key的前i位选择要放入的桶。

一旦某个桶满了，就分裂，位数 i++，重新散列元素。

**过程**：一开始 i=1，则有0和1两个桶，插入元素后，当某个桶满了，则只有该桶发生分裂，分裂通常导致i++，即桶数组翻倍（虽然桶数目只+1）。

- 优点：当查找记录时，只需查找一个存储块。
- 缺点：桶增长速度快，可能会导致内存放不下整个桶数组，影响其他保存在主存中的数据，波动较大。



#### 线性散列表

选择后 i 位作为桶的标号；

根据key的后 i 位放入到桶中（见例子）。

当桶满了，再插元素时，增加一个溢出块。（与可扩展散列表不同！）

当填充度 = 桶中存放的记录数 / 桶的总容量 ＞80%（也可以是其他规定值），增加一个桶，重新散列元素。

**例子**：

1. 当有5个桶时，i=3，桶标号分别为000，001，010，011，100，则对应的key放入对应的桶。
2. 如果此时插入一个key的后三位为101，没有对应的桶，则只看后两位，放入到001桶中。
3. 如果这时填充度超过80%，则分配一个新桶101，同时应该把之前将就着放到001桶里的部分元素放到这个桶里。

- 优点：空间效率优于可扩展散列表（每次只增加一个桶，严格控制在80%以内）
- 缺点：查找性能比可扩展散列表差（因为使用了溢出块）
- 综合性能较好



# 多维索引

R-Tree

分段散列函数（Partitioned Hash Function）