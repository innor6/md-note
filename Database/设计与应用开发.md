# 关系数据理论

关系模式：R(U, D, DOM, F)

- 关系名R是符号化的元组语义
- U为一组属性
- D为属性组U中的属性所来自的域
- DOM为属性到域的映射
- F为属性组U上的一组数据依赖

简化为：R(U, F)

## 规范化

数据依赖：完整性约束的表现形式，是现实世界属性间相互联系的抽象，是语义的体现。如函数依赖是指，通过一个属性X的值，可以推出另一个属性Y的值，则X→Y。

然而有些数据依赖使得一个模式中出现插入异常、删除异常、更新异常，数据冗余等问题，因此需要使用规范化理论来“分离”改造关系模式，以消除不合适的数据依赖，让一个关系描述一个概念，实质是“概念的单一化”。

### 函数依赖

1. 平凡函数依赖与非平凡函数依赖（非平凡，属性集Y不属于X）

2. 完全函数依赖与部分函数依赖（完全，属性集X的真子集X'不能推出Y）

   如，某个学生某门课程的成绩，不能单由学生或课程就能推出，即 (Sno, Cno)→F→Grade

3. 传递函数依赖（X→Y，Y→Z，Y!→X）

### 多值依赖

U的三个子集X,Y,Z，其中Z=U-X-Y，对于给定的值(x,z)，对应有多个y值，且y的值只取决于x，而与z无关，则X→→Y。

满足多值依赖的关系可以形成如下的完全二分图，其中W→→S且W→→C。

![多值依赖](C:\Users\64589\Documents\Tepora\Database\多值依赖.png)

多值依赖的性质：

1. 对称性（若X→→Y，则X→→Z，其中Z=U-X-Y，完全二分图）
2. 传递性（若X→→Y，Y→→Z，则X→→Z-Y）
3. 函数依赖是多值依赖的特殊情况（若X→Y，则X→→Y）
4. 若X→→Y，X→→Z，则
   - X→→YZ
   - X→→Y∩Z
   - X→→Y-Z，X→→Z-Y

多值依赖与函数依赖的区别：

1. 多值依赖的定义不仅取决于X和Y，还取决于U中的其余属性Z。因此嵌入型的多值依赖不一定在U上也成立。
2. 对于多值依赖X→→Y，不能断言X→→Y’成立（函数依赖可以）。
3. 

### 码

1. 候选码（也称码，U完全函数依赖于K，则K是候选码）
2. 主码（多个候选码中选一个）
3. 主属性（所有候选码共有的属性）
4. 非主属性（不包含在任何候选码中的属性）
5. 全码（整个属性组才能构成码）
6. 外码（属性X并非关系R的码，但X是另一关系的码）

### 范式

范式是符合某一种级别的关系模式的集合。
$$
1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF
$$
每一级范式都包含前一级的要求

**1NF**：每个分量必须是不可分开的数据项。

**2NF**：非主属性不<u>部分依赖</u>于候选码K。（每一个非主属性都完全函数依赖于任何一个候选码K。）

- 若非主属性对码不是完全依赖：插入异常、删除异常、修改复杂（投影分解法分解关系）

![2NF](C:\Users\64589\Documents\Tepora\Database\2NF.png)

**3NF**：非主属性不<u>传递依赖</u>于候选码K。

SC中无传递函数依赖，但S-L中Sloc对Sno传递函数依赖，应将其分解为S-D(Sno,Sdept)、D-L(Sdept，Sloc)

**BCNF**：每一个<u>函数依赖</u>（X→Y）的决定因素（X）都包含候选码K。

- 所有非主属性都完全函数依赖于每个候选码
- 所有主属性都完全函数依赖于每个不包含它的候选码
- 没有任何属性完全函数依赖于非码的任何一组属性

在函数依赖范畴内，满足BCNF的关系模式，实现了模式的彻底分解，达到了最高的规范化程度，消除了插入异常和删除异常。3NF的“不彻底”性表现在可能存在主属性对码的部分依赖和传递依赖。

**4NF**：每一个<u>非平凡多值依赖</u>X→→Y（Y不真包含于X，U-X-Y非空），X都含有候选码K。

**数据依赖的公理系统**（不会，略）

**分解**

关系模式R<U,F>的一个分解 {R1<U1,F1>，R2<U2,F2>，...，Rn<Un,Fn>}：

- 无损连接性：R1、R2、...、Rn的自然连接的结果与R相等。

- 保持函数依赖：U1、U2、...、Un互不相交，且函数依赖Fi为F在Ui上的投影。

如果一个分解具有无损连接性，则它能够保证不丢失信息；如果一个分解保持了函数依赖，则它可以减轻或解决各种异常情况。分解具有无损连接性和分解保持函数依赖是两个互相独立的标准。具有无损连接性的分解不一定能够保持函数依赖；同样，保持函数依赖的分解也不一定具有无损连接性。

若要求分解具有无损连接性，那么模式分解一定能够达到4NF；若要求分解保持函数依赖，那么模式分解一定能够达到3NF，但不一定能够达到BCNF。

# 数据库设计

对于给定的应用环境，构造优化的数据库<u>逻辑模式</u>和<u>物理结构</u>，建立数据库及其应用系统，使之满足<u>信息管理</u>要求和<u>数据操作</u>要求。

高效率的运行环境：

1. 数据库数据的存取效率高
2. 数据库存储空间的利用率高
3. 数据库系统运行管理的效率高

数据库设计的基本步骤：

![数据库设计的基本步骤](C:\Users\64589\Documents\Tepora\Database\数据库设计的基本步骤.jpg)

对应形成的各级模式：

应用需求→E-R图→关系模型→视图/物理存储

![数据库的各级模式 ](C:\Users\64589\Documents\Tepora\Database\数据库的各级模式 .png)

## 概念结构设计

将现实的用户需求抽象为信息结构。

**E-R模型**

实体间联系：(1:1)、(1:n)、(m:n)

三要素：实体（矩形）、实体的属性（椭圆）、实体间联系（菱形）。

可进行规范化。

![E-R图示例](C:\Users\64589\Documents\Tepora\Database\E-R图示例.png)

两条准则：

1. 作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性。
2. 属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。

## 逻辑结构设计

将E-R图转换为DBMS支持的数据模型的逻辑结构，即一组关系模式的集合。

转换原则：

1. 一个实体型转换为一个关系模式：
   - 关系的属性：实体的属性
   - 关系的码：实体的码
2. 实体间（1:1）的联系：
   1. 转换为独立的关系模式
      - 属性：与该联系相连的各实体的码、联系本身的属性
      - 候选码：每个实体的码
   2. 合并到某一端的关系模式中
      - 属性：加入另一端的码、联系本身的属性
      - 候选码：不变
3. 实体间（1:n）的联系
   1. 转换为独立的关系模式
      - 属性：与该联系相连的各实体的码、联系本身的属性
      - 候选码：n端实体的码？？
   2. √合并到“n”端对应的关系模式
      - 属性：加入“1”端的码、联系本身的属性
      - 候选码：不变
4. 实体间（m:n）的联系
   - 属性：与该联系相连的各实体的码、联系本身的属性
   - 候选码：各实体码的组合成的码
5. 三个及以上实体间的联系
   - 属性：与该联系相连的各实体的码、联系本身的属性
   - 候选码：各实体码的组合成的码
6. 具有相同码的关系模式可合并（去掉同义重复属性）

**数据模型的优化**

确定数据依赖→各关系模式间数据依赖极小化→分析各联系所属范式→是否符合应用要求→关系模式进行必要的分解。

- 并不是规范化程度越高越好，当查询经常涉及两个或多个关系模式的属性时，系统必须经常地进行连接运算，代价高，此时2NF甚至是1NF也许是适合的。
- 非BCNF的关系模式虽然会存在不同程度的更新异常，但如果在实际应用中对此关系模式只是查询，并不执行更新操作，就不会产生实际影响。
- 对于一个具体应用来说，到底规范化进行到什么程度，需要权衡响应时间和潜在问题两者的利弊才能决定。

分解的目的是提高数据操作效率和存储空间的利用率：

- 水平分解：将所有的元组分为若干个子集合，定义每个子集合为一个子关系，以提高系统的效率。将经常使用的元组（20/80）水平分解出来，形成一个子关系。或者每个事务存取的数据对应一个子关系。
- 垂直分解：把关系模式的属性分解为若干子集合，形成若干子关系模式。经常在一起使用的属性形成一个子关系。可能使另一些事务不得不执行连接操作，降低了效率。

## 物理结构设计

考虑因素：存取时间、存储空间利用率、维护代价。

关系模式的存取方法及适用的场合：

1. B+树索引存取方法
   - 属性经常在查询条件中出现
   - 属性经常作为最大值和最小值等聚集函数的参数
   - 属性经常在连接操作的连接条件中出现
2. Hash索引存取方法
   - 一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，且：
   - 该关系的大小可预知，而且不变；或该关系的大小动态改变，但所选用的数据库管理系统提供了动态Hash存取方法。
3. 聚簇存取方法
   - 将某个属性（称为聚簇码）上具有相同值的元组集中存放在连续的物理块中，以提高该属性的查询速度。索引项顺序与表中元组的物理顺序一样，因此一个基本表只能有一个聚簇索引。
   - 适合通过聚簇码进行访问或连接是该关系的主要应用的场合。
   - 很少对基本表进行增删操作
   - 很少对其中的变长列进行修改操作 

关系上定义的索引数过多会增加维护索引和查找索引的开销；聚簇只能提高某些特定应用的性能，建立与维护聚簇的开销相当大。

数据的存放位置：根据应用情况，将易变部分与稳定部分分开存放；经常存取部分与存取频率较低部分分开存放。

# 数据库恢复技术

## 事务（Transaction）

- 是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。
- 一个事务可以是一条SQL语句，一组SQL语句或整个程序。一个程序通常包含多个事务。
- 事务是恢复和并发控制的基本单位。

显式定义事务

```
BEGIN TRANSACTION
 SQL语句1
 SQL语句2
 ...
COMMIT --事务正常结束，提交操作（读+更新）

BEGIN TRANSACTION
 SQL语句1
 SQL语句2
 ...
ROLLBACK --事务异常终止，撤销所有已完成的操作
```

事务的ACID特性：

- 原子性（Atomicity）
- 一致性（Consistency）：数据库状态保持一致性
- 隔离性（Isolation）：并发的各事务间互不干扰
- 持续性（Durability ）：一旦事务提交，就是永久

**故障的种类**

1. 事务内部的故障
2. 系统故障
3. 介质故障
4. 计算机病毒

**恢复的实现技术**

- 数据转储：静态转储、动态转储，海量转储、增量转储。
- 登记日志文件：登记的次序严格按并发事务执行的时间次序；必须先写日志，后写数据库。

## 恢复策略

**事务故障**：

事务在运行至正常终止点前被终止。

恢复方法：利用日志文件，反向扫描文件日志，撤消（UNDO）此事务已对数据库进行的修改。

**系统故障**：

   1. 未完成事务对数据库的更新可能已写入数据库
   2. 已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库

恢复方法：正向扫描日志文件，撤销（UNDO）故障发生时未完成的事务，重做（REDO）已提交的事务。

**介质故障**：

恢复方法：装入最新的后备数据库副本，装入有关的日志文件副本，重做已完成的事务。

## 具有检查点的恢复技术

目的：提高恢复效率。

在日志文件中增加检查点（checkpoint）记录：

1. 按照预定的一个时间间隔，或某种规则，建立检查点；
2. 检查点记录当前时刻所有正在执行的事务清单，以及这些事务最近一个日志记录的地址。

恢复方法：

1. 撤销故障发生时还未完成的的事务；
2. 重做在检查点之后、故障发生前提交的事务；
3. 检查点之前提交的事务不必重做。

# 并发控制

事务是并发控制的基本单位。

并发控制机制的任务：

- 对并发操作进行正确调度
- 保证事务的隔离性
- 保证数据库的一致性

并发操作带来的数据不一致性：

1. 丢失修改（Lost Update）：两个事务读同一数据后，同时对其修改，如减一操作，使得一方的修改被覆盖丢失。
2. 不可重复读（Non-repeatable Read）：保证一个事务在结束前，读取同一个数据时得到的值是不变的。
3. 读“脏”数据（Dirty Read）：事务T1修改了数据后，数据被事务T2读取，但是事务T1并未结束，选择ROLLBACK恢复，则T2读到了脏数据。

并发控制的主要技术：

1. 封锁(Locking)
2. 时间戳(Timestamp)
3. 乐观控制法
4. 多版本并发控制(MVCC)

## 封锁

事务T对某个数据对象（表、记录）操作之前，先向系统发出请求，对其加锁。在事务T释放它的锁之前，其他的事务不能更新此数据对象。

- 排它锁（Exclusive Locks，X锁）：加锁后，只允许事务T读取和修改数据对象；其他事务不能再对该对象加锁，且不能读取和修改。

- 共享锁（Share Locks，S锁）：加锁后，事务T可以读但不能修改；其它事务只能再对其加S锁，保证其他事务可以读但不能修改。

**封锁协议**

- 一级封锁协议：事务T在修改数据之前必须对其加X锁，直到事务结束才释放。（可防止丢失修改）

- 二级封锁协议：事务T在读取数据之前必须先对其加S锁，<u>读操作结束后</u>即可释放S锁。（可防止读“脏”数据）

- 三级封锁协议：事务T在读取数据之前必须先对其加S锁，直到<u>事务结束</u>才释放。（可防止不可重复读）

## 封锁的粒度

封锁对象的大小称为封锁粒度(Granularity) 。

封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小。

封锁的对象：

逻辑单元：属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等；

物理单元：页（数据页或索引页）、物理记录等。

具有<u>意向锁</u>的<u>多粒度封锁</u>方法，可以提高系统的并发度，并减少加锁和解锁的开销。

**多粒度封锁**

在一个系统中同时支持多种封锁粒度。

多粒度树：

- 以树形结构来表示多级封锁粒度；根结点是整个数据库，表示最大的数据粒度；叶结点表示最小的数据粒度。（如数据库→关系→元组）
- 对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。显式封锁结点的后裔结点被隐式封锁。

因此封锁一个结点时，需要搜索父结点（检查该结点是否已被隐式封锁），也需要搜索子结点（检查子结点的显式封锁是否与要加的锁冲突）。

**意向锁**

用于提高对某个数据对象加锁时系统的检查效率。

对任一结点加基本锁，必须先对它的上层结点加意向锁；如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。

- 意向共享锁（Intent Share Lock，简称IS锁）：后裔结点拟加S锁。
- 意向排它锁（Intent Exclusive Lock，简称IX锁）：后裔结点拟加X锁。
- 共享意向排它锁（Share Intent Exclusive Lock，简称SIX锁）：对该结点加S锁，后裔结点拟加X锁。

申请封锁时应该自上而下的加锁；释放封锁时则应自下而上的释放。（范围是根节点到加锁/释放锁的结点）

**锁的强度**

X > SIX > S = IX > IS

申请封锁时，强锁可以代替弱锁，反之不然。

## 活锁和死锁

活锁：数据对象总是分配给其他事务，使得某一事务一直处于饥饿等待状态，可通过先来先服务等策略解决。

死锁：请求和保持+循环等待。

**预防死锁**：破坏死锁条件。一次封锁法，一次性将所需的数据全部加锁（降低了并发）；顺序封锁法，预先对数据对象规定一个封锁顺序（但数据库中数据量多且变化频繁）。

预防死锁不适合DBMS，通常采用诊断并解除死锁的方法。

**诊断死锁**：超时法（容易误诊）、循环等待图法。

**解除死锁**：选择一个处理死锁代价最小的事务，将其撤消；释放此事务持有的所有的锁，使其它事务能继续运行下去。

## 可串行性

并发事务的串行调度是正确的，执行结果等价于串行调度的调度也是正确的，称为可串行化(Serializable)调度。

可串行性(Serializability)：是并发事务正确调度的准则。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。

冲突操作：不同事务对同一数据的读写操作、写写操作。冲突操作不能交换次序。

冲突可串行化：一个调度Sc（即对各个事务各个操作的调度序列）通过交换两个事务不冲突操作的次序得到另一个调度Sc’，使得Sc’是串行地执行各个事务，则称调度Sc是冲突可串行化的调度。

- 冲突可串行化的调度，一定是可串行化的调度。反之不成立。

**两段锁协议**

DBMS普遍采用两段锁协议的方法实现并发调度的可串行性。

1. 对数据进行读、写操作之前，事务首先要获得该数据的封锁；
2. 释放一个封锁后，事务不得再申请获得其他封锁。

将对锁的申请和释放分为了两个阶段，扩展-收缩，即开始只能封锁，后面只能解锁。

- 遵守两段锁协议的事务，一定是可串行化调度的。反之不成立。

两段锁协议不能防止死锁。
