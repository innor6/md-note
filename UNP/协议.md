[TOC]



### ARP：地址解析协议

从逻辑IP到对应物理硬件地址的翻译。在物理网络内发送。

1. 提供32bitIP地址-->48bit以太网地址的映射。（不一定是以太网，也可以是其他的物理网络）
2. 一个网络接口有一个硬件地址；点对点链路不使用ARP。
3. RARP提供逆向的映射。
4. ARP是硬件自动完成的动态映射，对应用程序和管理员透明；而RARP被无盘工作站使用，需要管理员手动设置。

**ARP过程**(2ms)：

在以太网内发送一个IP数据报时，若不知道目标主机的MAC地址，需要进行ARP。

1. 广播：发送一份ARP请求的以太网帧（who-has 192.168.1.109）给以太网上的每个主机。

   - 太网广播地址为ff:ff:ff:ff:ff:ff

   - 帧数据中包含 [MAC: IP] 四元组表，其中目的主机的MAC为全0，稍后由目的主机填写

2. 应答：目的主机识别出请求的是是自己的IP后，发送一个ARP应答，包含IP和对应的MAC（192.168.1.109 is at xx:xx:xx:xx:xx:xx）

### DNS：域名系统

将域名转换为ip地址。

应用程序请求TCP打开连接或用UDP发送数据报之前，必须先把主机名转换为一个IP地址。

端口号53，一般用UDP。

查询方式：分为递归、迭代。



# 路由选择协议

### RIP

封装：UDP

距离向量（DV）法：Bellman-Ford算法，Dist ij = Cost iN + Dist Nj（松弛）【三重循环：i、j、n】

每个路由器只完成算法的一部分。



路由表信息：【目的网络、代价、下一跳】。

过程：

1. 路由器定期向邻站广播自己的整个路由表（30s，代价太大）
2. 收到邻站发来的记录后，如果发现更好的路由/下一跳相同，则更新该条路由（距离+1）

问题：

坏消息可能传的慢。计数到无穷大例子：路由器A连接一条故障路由，将其距离标为16，**如果**此时A的邻站B定时发送更新通告，更新了A的路由表，使得到故障路由的距离变为3（A-B-A-故障路由），AB互相通告，距离不断+1，一直要加到16才停止，这时才知道那条路由发生故障。

解决方案：

分割范围+毒性逆转。当向路由器A发送通告时，如果记录原本就来自A（可通过下一跳判断），则将距离标为无穷大（16），这样A就知道不用处理这条记录。从源头上避免问题。

计时器：

1. 定时广播
2. 每条有效记录有一个失效计时器
3. 无用信息计时器：失效的记录不立即删除，继续向邻站通告该记录，直到该计时器过期

RIP v2：

使用多播，并且支持CIDR，增加了下一跳字段（v1只有目的网络和距离）。



### OSPF

封装：IP

链路状态：

每个结点拥有整个域的网络拓扑，使用Dijkstra算法（选择根节点，作为初始的生成树；每次从其他点中选择一个距离根节点（D(x)+c{x,y}）最近的一个点y，加入到生成树中；随后更新树之外的其他结点到生成树的距离）计算自己的最小生成树，就是从该结点到其他结点的最短路径。

泛洪：

一个顶点生成自己的链路状态分组（LSP：结点标识（顶点），链路列表（边），该分组的序号，该分组的寿命），向所有结点发送：

1. 域的拓扑发生变化时，就泛洪通知域中所有结点

2. 定期泛洪，以确保删除旧的信息（2h）

接收方：

- 如果收到更加新的LSP，则更新，并向其他接口转发这个LSP（因此泛洪会在残桩结点终止）。

- 如果收到旧的，已经收到过该LSP就不再转发，直接丢弃。（有点类似谣言的传播模型，猜测可在logN时间内完成泛洪）



区域：OSPF将一个自治系统划分为多个区域，减少泛洪通信量。每个区域都有标识，区域内网络连通。

边界路由器：每个区域边界有边界路由器，用于汇总本区域内信息，并发送到其他区域。

主干：若干个路由器连接所有的区域。

链路类型：

- 点对点链路：连接另一个路由器
- 穿越链路：连接到一个网络，该网络有多个出口（该网络连接到多个路由器）
- 残桩链路：连接到一个网络，该网络只有这个出口
- 虚拟链路：两个路由器之间断开，用经过好几个路由器的虚拟链路代替



### BGP

封装：半永久的TCP连接:179

域间路由选择算法。

当区域内跳数较多时：

- 距离向量：路由选择变得不稳定
- 链路状态：计算路由表消耗资源大，泛洪通信量大。

因此使用“路径向量”法

- 距离向量告诉我们达到每个网络的距离，

- 路径向量告诉我们到达每个网络的路径。

可达性：

每个自治系统需要有一个列表，列出该区域内有哪些网络。



# IP模块

数据链路层有很多协议，如以太网、分组交换网，IP层将格式不同的“帧”转换成了格式统一的“IP数据包”，使得不同的局域网（网络）之间可以互通。

路由器转发过程中，IP数据包的源IP、目的IP始终不变

分片：由于片偏移的单位为8字节，因此前面的分片数据部分是8的倍数（如20+1480），最后一个分片不用MF（more fregment）标志位

主机启用转发功能：`echo 1>/proc/sys/net/ipv4/ip_forward`

校验和：IP数据包只校验头部，TCP校验头部+数据（保证可靠）。

# TCP模块

**MSS**：最大分节长度，数据部分长度，MTU-20-20（IP、TCP头部）

**TIME_WAIT**：等待2MSL，最大报文生存时间

- 可靠的终止TCP连接：主动关闭端收到FIN后，其发送的ACK可能丢失，则会在最长2MSL的时间内收到对方会重传的FIN。

- 让本次TCP连接的所有数据报都从网络上消失，防止与下次连接的报文混淆。

  （可用选项：SO_REUSEADDR端口重用，无需等待，立即使用处于TIME_WAIT状态的端口）

**RST**：

1. 发起连接：目标端口不存在，或处于TIME_WAIT状态
2. 终止连接：异常地终止一个连接（相对于FIN）
3. 处理半打开连接：服务器崩溃重启，连接已不存在，没法发送FIN，另一方不知情，继续向不存在的连接write，则收到RST

解决糊涂窗口综合征（指发送报文段中数据部分小，显得报文段的报头开销很大）：

**交互数据流——Nagle算法：**

通过累计多个分节，单次发送，减少网络中的TCP分节、防止拥塞，避免糊涂窗口综合征（发小分节利用率低）。

最多只允许有一个未确认ACK：每次发完一个TCP分节后，直到收到ACK，或累积的数据量超过MSS后，才继续发下一个TCP分节。

特点：确认到达越快，数据发的越快。

缺点：两次数据的发送间隔一个RTT，延迟会变高，影响请求流水线，带宽利用率低。

解决办法：

1. 建立缓冲区，将多个发送请求合并发送；
2. 禁用：TCP_NODELAY

**交互数据流——延迟确认：**

收到数据后，不是马上ACK，而是在下一次发送数据、或快超时时捎带这个ACK。

只适用于处理请求较快的场景。可以减少网络中报文段数量。



**UDP  vs TCP**

TCP：面向连接的、可靠的、字节流

UDP：无连接的、不可靠的、数据报

TCP有流量控制和拥塞控制。

**并发**

TCP：线程不安全，因此服务器一般一个客户分配一个sockfd

UDP：线程安全，服务器只需一个sockfd即可

##### TCP的可靠性

数据无差错、不丢失、不重复、且按序到达。

- 确认应答（ACK）：数值为期待收到的下一个字节的序号

- 超时重传

- 序列号（seq）确保有序：该报文段的第一个字节在整个字节流的偏移

- 校验和：校验头部+数据
- 流量控制、拥塞控制、连接管理

##### TCP拥塞控制

拥塞控制：防止过多的数据注入网络中，调整网络负载和吞吐量；

流量控制：抑制发送端发送数据的速率，便于接收端来得及接收。（滑动窗口）

1. **慢开始**：指数增大
   - 发送方维护一个拥塞窗口（cwnd = 1）
   - 从 1 MSS（最大报文段长度）开始，每收到一个确认ACK，拥塞窗口就增大一个MSS
   - 每过一个RTT，窗口大小翻倍，指数增大
2. **拥塞避免**：加法增大
   - 当 cwnd 达到慢开始门限（ssthresh = 16），使用拥塞避免算法
   - 当一整个窗口的报文段都被确认后，即每经过一个往返时间RTT，就把发送方的cwnd加1
3. **拥塞检测**：乘法减小
   - 当需要重传，说明可能发生拥塞了：
     - ssthresh 置为当前 cwnd 的一半
   - 如果是计时器超时导致重传，出现拥塞的概率较大
     - 令 cwnd = 1MSS
     - 进入慢开始
   - 如果是收到三个ACK（发送方连续收到3次对同一个报文段的重复确认），则可能是报文丢失，而非网络拥塞，因为3个ack说明后面的报文段已经安全收到
     - <u>快重传</u>：立即发送缺失的报文段
     - <u>快恢复</u>：cwnd = ssthresh
     - 进入拥塞避免

流量控制和拥塞控制共同调整发送方的窗口：上限值为**Min（rwnd，cwnd）**



**为什么TCP要三次握手？**

答：TCP通过确认重传机制来保证可靠连接。

- SYN-SEND：A先发起连接请求SYN
- SYN-RCVD：B接收到后返回一个ACK表示接收到请求，也发起连接请求SYN
- ESTABLISHED：A收到后返回一个ACK表示成功接收
- ESTABLISHED：B收到后也确定连接建立

从而双方都确定对方收到了自己的连接请求，于是连接就建立了。

（其中第二步里的两个步骤可以合并，是因为连接建立时没有数据传输，这几个数据报必定是按顺序连续出现的，合并可以减少发送的报文数目；而关闭连接时，一方半关闭写后，另一方还能传输数据，因此需要四次挥手）



**四次挥手**

- FIN-WAIT1：A发送FIN（半关闭，表示不再有更多数据要写，但之前发的数据还是可以超时重传（保存在滑动窗口里））
- CLOSE-WAIT：B确认ACK，B还能继续发送数据，等待B调用close()
- FIN-WAIT2：A收到确认ACK
- LAST-ACK：B调用close()，发送FIN，等待最后一个ACK
- TIME-WAIT：A发送最后一个ACK，该状态等待两个MSL（maximum segment lifetime）

（这里A称为主动关闭方，TIME-WAIT一定发送在主动关闭的一方）



**为什么TIME-WAIT状态等待2MSL？**

1. 确保主动关闭方发送的最后一个ACK能够被对方收到（否则对方之前发的FIN会超时重传，...）
2. 保证这个TCP连接的所有报文段都消失在网络中，使得这些报文不会影响到下一次相同socket pair的TCP连接。