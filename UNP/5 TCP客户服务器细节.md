# 处理僵死进程

1. 当fork子进程时，必须捕获 `SIGCHLD` 信号；
	（由父进程调用 `wait` 、 `waitpid` 来清理僵死子进程）
2. 当捕获信号时，必须处理被中断的系统调用；
   （中断可能导致慢系统调用返回错误）
3.  `SIGCHLD` 的信号处理函数必须正确编写，应使用 `waitpid` 函数以免留下僵死进程。
   （Unix信号不排队，同时收到的多个信号容易被忽略）



# 服务器进程终止

**当服务器进程终止时，客户进程应该能立刻被告知。**

（IO复用： `select` 、 `poll` ，进程不阻塞在IO调用上）

服务器进程：

服务器进程终止后，套接字描述符（sockfd）被系统关闭，TCP向客户端发送 `FIN` ，此时服务器已经无法再接收数据，若从客户端收到数据，将返回一个 `RST` ；

客户进程：

1. 若在收到 `FIN` 后（读半关闭）执行读操作，读到`EOF`
2. 若在收到 `RST` 后执行写操作，触发 `SIGPIPE` 信号， `write` 返回 `EPIPE` 错误；
3. 若在收到 `RST` 后执行读操作， `read` 返回 `ECONNRESET` 错误；



# 服务器主机崩溃

**服务器主机崩溃要到客户向服务器发送了数据才能检测到。**

（ `SO_KEEPALIVE` 套接字选项，或心跳协议）

客户发送的数据由于收不到 `ACK` 确认，会持续重传，最后返回 `ETIMEOUT` 超时错误，或根据ICMP信息返回 `EHOSTUNREACH` 或 `ENETUNREACH` 目的地不可达错误。



# 数据格式

发送数值数据时会出现的问题：

1. 字节序：大端/小端字节序；
2. 数据类型的位数：32位/64位的int；
3. 结构体打包方式的差异：数据类型的位数、对齐限制。

解决方法：

1. 使用文本串来传递数值数据；
2. 显示定义数据类型的二进制格式（位数、字节序）。