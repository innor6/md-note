### Decorator

（wrapper）

**定义**：通过组合，动态地给一个对象添加额外的职责。比继承更灵活。

**动机**：希望给某个类动态地添加一些额外功能。

**例子**：流，有文件流、网络流等基本流，又有加密流、缓冲流等作为扩展功能的流，但是加密、缓冲应该属于可以复合嵌套的额外功能。

**适用性**：

1. 动态、透明的给单个对象添加职责。往往是可以多重嵌套的职责。
2. 可撤销的职责。
3. 用继承可能导致子类数目膨胀。

**结构**：

- Component：抽象基类，定义对象的接口。子类实现具体的职责。
- Decorator：抽象类，继承component的接口。
  - 包含一个指向component的指针。
  - 子类实现全部的component的接口，在实现时通过操作component指针，来扩展component的功能职责。

**总结**：

1. 实现了运行时扩展对象功能的能力，避免了子类膨胀。
2. 接口上表现为 is a component 的继承关系，实现上又表现为 has a component，即在底层使用了另一个component对象。
3. 应用要点是“主体类”在多个方向上的功能扩展，而非解决子类膨胀问题。

**对比：改变对象外壳与改变对象内核**

Decorator可以看作一个对象的外壳，它可以改变对象的行为。

但当component本身很大时，Decorator实现全部接口的代价高，使用Strategy模式来改变对象某个接口的功能更合适。

Decorator对组件是透明的，可以在运行时添加修饰；而如果组件使用Strategy，组件应该需要知道有哪些Strategy可以选用。  