# 拷贝控制

定义一个类时，我们显式或隐式地指定在此类型的对象**拷贝、移动、赋值、销毁**时做什么。

一个类通过定义五种特殊成员函数来控制这些操作：

1. 拷贝构造函数
2. 拷贝赋值运算符
3. 移动构造函数
4. 移动赋值运算符
5. 析构函数

其中1、3定义了用同类型对象来初始化本对象时的行为，2、4定义了用同类型对象赋值时的行为，析构函数定义了此类型对象销毁时的行为，这些操作称为拷贝控制操作。

在定义任何C++类时，拷贝控制操作都是必要的部分，如果不显式定义这些操作，编译器也会为我们定义，但其行为可能并非我们所想。

## 1 拷贝、赋值与销毁

### 1.1 拷贝构造函数

拷贝构造函数的第一个参数是**自身类型的常量引用**，且额外参数都有默认值。

```c++
Foo(const Foo&);
```

拷贝构造函数在几种情况下会被隐式地使用，因此通常不应该是`explicit`的。

##### 调用时机

- 使用`=`定义变量
- 把对象作为实参，传递给一个<u>非引用类型</u>的形参
- 把对象作为函数的返回，返回类型为<u>非引用类型</u>
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 某些类类型会对它们所分配的对象进行拷贝初始化，如初始化标准库容器、insert、push

将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换（隐式转换可能会被explicit禁止）。

```c++
string s = "Hello world!"; //先发生了隐式转换生成临时string对象，然后进行拷贝构造
```

拷贝初始化通常使用拷贝构造函数来完成。但如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。

##### 自动合成拷贝构造

如果没有定义拷贝构造，编译器一定会自动合成一个，将参数的非static成员逐个拷贝到正在创建的对象中。拷贝过程是对每个成员逐个地调用它们自己的拷贝构造：类类型成员，使用其拷贝构造函数；内置类型成员，则直接拷贝；数组成员，进行逐元素的拷贝。

注意：如果类中成员是一个指针，如果调用默认的拷贝构造，只是将指针地址进行拷贝，即发生“浅拷贝”，两个指针会指向同一个对象（有时这不是我们想要的）。另外，如果指向的是动态对象，浅拷贝将原指针地址覆盖，原动态对象丢失，导致内存泄漏，此时应该先`delete`原对象再进行拷贝。

##### 绕过拷贝构造函数？

在上面“拷贝初始化”的代码中，首先进行了隐式转换生成临时的string对象，随后才进行拷贝初始化。

实际上，编译器允许跳过拷贝构造函数直接创建对象，使临时变量成为所要创建的对象（要求拷贝构造函数在当前节点是可见的，如不能为private）。即上面的代码被编译器优化为：

```c++
string s("Hello world!"); //赋值运算符-(优化为)->拷贝构造
```

### 1.2 拷贝赋值运算符

##### 重载赋值运算符

```c++
Foo& operator=(const Foo&) { return *this;}
```

赋值运算符必须定义为成员函数，`=`左侧的运算对象被绑定到隐式的this参数，右侧为显式传递的参数。赋值运算符通常应该返回一个指向其左侧运算对象的引用。

##### 合成拷贝赋值运算符

与拷贝构造函数一样，如果类未定义拷贝赋值运算符，则会自动合成。它会将右侧对象的非static成员拷贝赋值给左侧运算对象的对应成员。

### 1.3 析构函数

析构函数释放对象使用的资源，并销毁对象的非static成员。它没有返回值，也不接受参数。

```
~Foo();
```

由于不接受参数，因此无法被重载，一个类只有唯一一个析构函数。

与构造函数相反，析构过程首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。（即构造发生在构造函数之前，析构发生在析构函数之后）

函数体自身并不直接销毁成员，成员的销毁是在后续的析构阶段隐式自动完成的。

析构阶段调用成员自己的析构函数，内置类型没有析构函数，隐式销毁一个普通指针不会`delete`它所指向的对象，对象的引用或指针离开作用域时析构函数不会执行。因此函数体的一种用途是用于释放指针成员所指的动态对象。

##### 调用时机

- 变量离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（标准库或数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用`delete`时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

析构函数自动运行，使得我们的程序可以按需分配资源，而（通常）无须担心何时释放这些资源。

##### 合成析构函数

若类未定义析构函数，编译器会自动合成，函数体为空。

### 1.4 三/五法则

在一个类中可以定义的五个拷贝控制操作中，可以只定义其中几个，而不必定义所有。以下原则可以用于判断一个类是否要定义自己版本的拷贝控制成员。

- 涉及<u>资源管理</u>（如分配动态内存）的类一定要自定义析构函数，来释放资源。
- 需要析构函数的类也需要拷贝构造和拷贝赋值操作，即在拷贝时对资源进行特殊的拷贝操作。
- 需要拷贝操作的类也需要赋值操作，反之亦然。
- 要求每个类对象（的某个成员）具有<u>独特的值</u>的类，需要定义自己拷贝构造和拷贝赋值，来保证拷贝时每个类的id不同。
- 在拷贝开销较大且非必要的情况下（拷贝后rhs不再使用），使用移动操作代替拷贝操作效率会更高。

### 1.5 使用=default

【C++11】可以显式的要求编译器生成合成版本的拷贝控制成员：

```c++
class Foo() {
public:
	Foo() = default;            //默认构造
    Foo(const Foo&) = default;  //拷贝构造
    Foo& operator=(const Foo&); //拷贝赋值
    ~Foo() = default;           //析构函数
}
Foo& Foo::operator=(const Foo&) = default; //定义在类外则不是内联函数
```

### 1.6 阻止拷贝

对于某些类来说，一些拷贝控制操作是无意义的，例如iostream不允许拷贝或赋值，定义这些类时应该采用某种机制阻止拷贝或赋值。

##### 定义删除的函数

【C++11】可以使用`=delete`来定义删除的函数，通知编译器我们不希望定义这些成员。

```c++
Foo(const Foo&) = delete;            //删除拷贝构造
Foo& operator=(const Foo&) = delete; //删除拷贝赋值
```

`=delete`必须出现在函数第一次声明的时候，且可对任何函数指定`=delete`。

如果一个类有数据成员不能被默认构造、拷贝、赋值或销毁，则对应的拷贝控制函数将被定义为删除的：

- 一个成员有删除的或不可访问的（例如：是private的）析构函数会导致合成的默认和拷贝构造函数被定义为删除的。
- 对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数和拷贝赋值运算符。

##### private拷贝控制

曲线救国：旧版标准库可以通过将拷贝构造函数和拷贝赋值运算符声明为`private`来阻止拷贝。

但是友元、成员函数仍然可以访问private部分，为了能预先发现它们使用拷贝，需要将拷贝控制成员声明为private，但不定义它们（声明但不定义一个成员函数是合法的），试图访问一个未定义的成员将导致一个（编译阶段）链接时错误，从而预先阻止任何拷贝该类对象的企图。



## 2 拷贝控制和资源控制

通常，管理类外资源（如动态对象）的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源（否则会内存泄漏），那么它一定也需要定义自己的拷贝构造和赋值运算符（浅拷贝将产生悬空指针），来管理这些类外资源。

定义拷贝控制之前，需要确定拷贝语义：

- 行为像值：如拷贝一个string对象，副本和原对象完全独立，互不影响。
- 行为像指针：如拷贝shared_ptr，副本和原对象使用共同的底层数据，改变副本也会改变原对象。
- 行为不像值，也不像指针：如IO对象和unique_ptr，不允许拷贝和赋值。

赋值操作会析构左侧对象，并从右侧对象拷贝数据，需要注意：

- 自赋值：自我赋值可以正确执行。
- 异常安全：异常发生时，能保证左侧对象处于有意义的状态。

##### 行为像值

即拷贝后的对象是一个独立的副本。

- 拷贝构造时，动态分配新对象，作为原对象的副本
- 析构时，释放动态分配的对象
- 赋值时，先拷贝右侧对象，然后析构左侧对象，并将临时副本赋值给它

这里以一个含有string指针成员的类为例：

```c++
class HasPtr {
public:
    HasPtr(const string& s = string()) : ps(new string(s)) {} //默认构造，动态分配一个对象
    HasPtr(const HasPtr& p) : ps(new string(*p.ps)) {} //拷贝构造，动态分配一个对象的副本
    HasPtr& operator=(const HasPtr&); //赋值运算符，定义见下文
    ~HasPtr() { delete ps;} //析构函数释放分配的动态对象
private:
    string *ps;
}
```

通过先拷贝右侧运算对象，可以处理自我赋值的情况，并保证了异常安全：

```c++
HasPtr& HasPtr::operator=(const HasPtr& rhs){
    auto newp = new string(*rhs.ps); //构造一个临时对象，保存右侧对象
    delete ps; //析构左侧对象
    ps = newp; //赋值
    return *this;
}
```

##### 行为像指针

即拷贝后的对象与原对象共用底层数据，使用“引用计数”。

- 所有对象共用一个保存在动态内存中的引用计数
- 拷贝构造时直接拷贝指针的值，同时递增引用计数
- 析构函数只有在动态对象的引用计数为0后才释放对象
- 赋值时，修改两侧的引用计数，析构左侧对象，然后直接拷贝指针的值

最好的方式是使用shared_ptr作为成员来管理资源，这里不使用shared_ptr，而是使用一个保存在动态内存中的引用计数来实现：

```c++
class HasPtr {
public:
    HasPtr(const string& s = string()) : ps(new string(s), use(new size_t(1))) {}//默认构造
    HasPtr(const HasPtr& p) : ps(p.ps), use(p.use) { ++*use; } //拷贝构造，直接拷贝指针，递增引用计数
    HasPtr& operator=(const HasPtr&); //赋值运算符声明
    ~HasPtr(); //析构函数
private:
    string *ps;
    size_t *use; //引用计数，被所有对象共享
}

HasPtr::~HasPtr() {
    if(--*use == 0) { //当引用计数变为0，才释放动态对象
        delete ps;
        delete use;
    }
}

HasPtr& HasPtr::operator=(const HasPtr& rhs){
    ++*rhs.use; //递增右侧的引用计数
    if(--*use == 0) { //析构左侧对象，若引用计数为0则
        delete ps;
        delete use;
    }
    ps = rhs.ps; //构造左侧对象
    use = rhs.use;
    return *this;
}
```



## 3 交换操作

管理资源（动态分配内存）的类，除了拷贝控制，通常还定义一个名为swap的函数，特别是那些与重排元素顺序的算法一起使用的类，这类算法在需要交换两个元素时会调用swap。

如果一个类定义了自己的swap，那么算法会使用自定义的版本，否则算法将使用标准库定义的swap。（类型匹配）

交换操作包含一次拷贝和两次赋值：

```
HasPtr temp = v1;
v1 = v2;
v2 = temp;
```

显然，如果直接交换对象，将会包含不必要的多次对象的拷贝和赋值操作。有时我们只希望交换对象的内部成员，则需要重载swap：

```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&); //将重载swap定义为友元，使其能访问内部成员
}
inline void swap(HasPtr& lhs, HasPtr& rhs) { //swap通常作为内联函数
    using std::swap; //???
    swap(lhs.ps, rhs.ps); //交换内部成员
    //有些类除了交换内部成员，还需要一些其他的操作，特别是涉及修改索引链接、释放动态内存等情形
}
```

##### swap与std::swap

有一个微妙的地方是，交换成员时，应该使用成员类型特定的swap，而不是std::swap（且需要写上` using std::swap;`）。当然，由于自定义swap的类型匹配程度优于std版本，所以会自动调用自定义版本的swap。

##### “拷贝并交换”赋值

赋值运算符可以使用“拷贝并交换”技术，要求类中定义了swap，用于更优雅的分配动态内存，先拷贝右侧对象，然后调用swap交换副本和左侧运算对象：

```c++
HasPtr& operator=(HasPtr rhs) { //注意！这里的参数不再是引用，值传递一个副本
    swap(*this, rhs); //交换成员后，rhs变量指向lhs原来使用的内存
    return *this;
} //退出函数后，rhs被销毁，原来的内存也被释放
```

这种技术可以正确处理自赋值，并且是异常安全的。



## 4 两个示例

《C++ Primer 5th》在从P460页开始提供了两个示例：

利用拷贝控制设计两个类，Message和Folder，每个Message都记录了自己出现在哪些Folder中，每个Folder也记录了其中含有的Message。

利用allocator实现了一个动态内存管理类，作为vector的简化版本，其中的元素使用string类型。



## 5 对象移动

【C++11】新标准库提供了移动而非拷贝对象的能力。

可以认为移动其实是“窃取”了一个对象中的数据，移动后该对象中的数据状态不确定，尽量不要再次读取。

移动操作主要用于在赋值时代替拷贝，提高效率。

1. 对象拷贝时，如果在对象拷贝后就立即销毁，使用移动而非拷贝对象会大幅提升性能。
2. 另一种情形是像IO类或unique_ptr类这种包含不能被共享的资源，它们不能被拷贝，但是可以移动。

标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。

### 5.1 右值引用

为了支持移动操作，新标准库引入了右值引用（rvalue reference），

右值引用就是必须绑定到右值的引用，用&&而不是&来获取右值引用。它有一个很重要的特性——只能绑定到一个将要销毁的对象，也因此我们可以自由的移动右值引用的资源。

##### 左值和右值

左值和右值是表达式的属性，一般而言，左值表示对象的身份，右值表示对象的值。

另外，const的左值引用可以绑定到右值表达式上。

- 返回左值的表达式：返回引用的函数、赋值、下标、解引用、前置递增/递减运算符。
- 返回右值的表达式：返回非引用类型的函数、算术、关系、位、后置递增/递减运算符。

可以看出，左值有持久的状态；而右值要么是字面常量，要么是表达式求值过程中的临时对象。这些右值对象将要被销毁，且没有其他的用户。

##### 不能右值引用右值引用变量

变量都是左值，因此不能右值引用一个右值引用类型的变量：

```c++
int &&rr = 42;
int &&rr2 = rr; //错误：rr是一个左值
```

##### std::move

调用std::move可以将左值转化为右值：

```c++
int &&rr3 = std::move(rr); //正确：将一个左值转换为对应的右值
```

注意不需要使用using，并且应该使用std::move而不是move，避免潜在名字冲突。

### 5.2 移动构造函数和移动赋值运算符

定义了移动操作后调用`std::move`可以移动对象：

```c++
T a2 = std::move(a); //move返回右值，匹配到移动构造函数，构造新对象
```

只有确定移动一个对象是安全的，即承诺不会再使用移后源对象，才可以使用std::move。注意与swap不同，不需要使用using，并且应该使用std::move而不是move，避免潜在名字冲突。

##### 移动构造函数

- 移动资源、拷贝/移动成员
- 令源对象进入<u>可析构状态</u>：一旦资源移动完成，源对象必须不再指向被移动的资源，即这些资源的所有权已经归属新创建的对象。移后源应该可以随时被销毁，且不影响移动后的资源。

类似拷贝构造函数，第一个参数为自身类型的右值引用：

```c++
class HasPtr {
public:
    /*其他函数省略*/
    HasPtr(HasPtr&& p) noexpect //noexcept通知编译器该函数不抛出异常
        : ps(p.ps)              //初始化列表接管p中资源
    { p.ps = nullptr; }         //使移后源p可以被安全地析构
private:
    string *ps;
}
```

##### 异常

由于移动操作通常不分配任何资源，因此通常不会抛出任何异常。使用`noexcept`向编译器保证该函数是异常安全的（即发生异常后，类对象自身不会改变）。确定不会抛出异常的移动构造函数、移动赋值运算符必须标记为`noexcept`，声明和定义都要写`noexcept`。

##### 移动赋值运算符

移动赋值运算符执行与析构函数和移动构造函数类似的工作。

```c++
HasPtr& HasPtr::operator=(HasPtr &&rhs) noexcept //不抛出异常
{
    if (this != &rhs) {    //检测自赋值
        delete ps;        //释放已有对象
        ps = rhs.ps;      //从rhs接管资源
        rhs.ps = nullptr; //置rhs于可析构状态
    }
    return *this;
}
```

##### 移后源状态

移动操作必须确保移后源对象：

- 进入可析构状态，即移后源对象应该可以随时被安全销毁，不会影响移动后的资源。上面的代码中我们使用将指针置空来满足这一要求。
- 对象仍然是有效的，即可以安全地为其赋予新值。
- 用户不应该随意使用其内部数据，移后源对象中留下的值不一定是正常的值，程序不应该使用移后源对象中的数据。

##### 合成移动操作

如果一个类定义了自己的拷贝构造、赋值运算符、析构函数，则不会自动合成移动操作。

如果一个类定义了移动操作，必须也定义自己版本的拷贝操作，否则拷贝操作被默认地定义为删除的。

如果一个类没有移动操作，通过正常的函数匹配，会使用对应的拷贝操作来代替移动操作。

只有当一个类没有定义任何自己版本的拷贝控制成员，且每个非static成员都可以移动时，才会合成移动构造和移动赋值运算符。

合成的移动操作永远不会隐式定义为删除的函数，除非：成员没有移动操作、成员的移动操作被删除或不可访问、析构函数被删除或不可访问、类成员为const或引用。

##### 移动or拷贝

可以看到移动操作、拷贝操作的函数名称的是一样的，通过类型匹配（左值/右值）来选择对应的操作。

左值被拷贝，右值被移动：如果一个函数返回了一个右值（即非引用类型），并将其赋值给一个变量，那么根据类型的精确匹配，会调用移动赋值（如果调用拷贝赋值则需要进行一次到const的转换）。

如果没有移动构造函数，右值的实参也会调用拷贝构造函数（Foo&& -> const Foo&），即使显式使用`std::move`也会调用拷贝构造。（即拷贝操作可以安全的替代移动操作）

##### 拷贝并交换

用一个赋值运算符同时实现拷贝、移动两种赋值运算（要求类已经定义了拷贝构造和移动构造）：

需要用到“拷贝并交换”技术，即参数类型设为非引用，“拷贝/移动”传入对象。

```c++
HasPtr& operator=(HasPtr rhs) { //参数一个非引用对象，传参过程会对其进行拷贝初始化
    swap(*this,rhs);            //取决于实参类型，拷贝初始化调用拷贝构造函数or移动构造函数，
    return *this;
}

hp = hp2;            //实参hp2为左值，拷贝构造形参rhs
hp = std::move(hp2); //实参为std::move返回的右值，精确匹配到移动构造，构造rhs
```

不论实参是左值还是右值，赋值运算符的函数体都swap两个运算对象的状态。赋值结束后，rhs离开作用域，rhs对象被销毁（如果是移动构造的，则相当于源对象被销毁）。

但是！！：

这样每次赋值时，需要先将对象拷贝到rhs，再将rhs与*this进行swap，效率并不理想。如果分别定义拷贝赋值、移动赋值运算符，则不需要额外的swap操作。

另外要么分别定义拷贝赋值、移动赋值，要么只定义拷贝并交换赋值，一起出现会导致类型匹配模糊，重载失败。

##### 移动迭代器

一种适配器，可以令迭代器的解引用运算符返回一个右值引用。

```c++
auto miter = make_move_iterator(iter); //迭代器->移动迭代器
```

动态数组管理中使用`uninitialized_copy(b, e, b2)`算法可以将元素拷贝到未初始化的内存中，它对每个元素调用`construct(p, args)`来构造新元素。如果将`[b,e)`迭代器转化为移动迭代器，则解引用返回右值，即`args`为右值，调用移动构造函数来构造新元素。

注意，标准库不保证哪些算法适用移动迭代器。由于移动一个对象可能会销毁原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它，才能将移动迭代器传递给算法。

### 5.3 成员函数

类似于构造函数和赋值运算符，其他的成员函数也可以重载得到拷贝、移动版本：即令两个版本的参数类型分别为const左值引用`const T&`、右值引用`T&&`，从而分别接受为左值、右值的实参。

当我们需要从实参“窃取”数据时，对函数传递一个右值，调用移动版本。在函数体内需要的赋值的地方，也利用`std::move`返回的右值引用来进行赋值，实现移动。

##### 引用限定符

旧标准中，可以在右值上调用成员函数，向一个右值赋值也是允许的，如：

```c++
auto n = (s1 + s2).find('a');
s1 + s2 = "wow!";
```

新标准中，对于一个成员函数，我们可以限定调用它的对象（*this）必须是一个左值/右值。在参数列表后加上一个引用限定符`&`/`&&`，表示调用者this必须指向一个左值/右值：

```c++
Foo& operator=(const Foo&) &; //只有左值对象可以调用
Foo fun1(); //此函数返回一个右值
fun1() = 10; //错误：上面定义的=运算符要求*this为左值，但fun1返回的是右值
```

类似于const限定符，引用限定符只能用于（非static）成员函数，且必须同时出现在声明和定义中。引用限定符必须写在const之后。

##### 重载成员函数

成员函数可以根据限定符来区分重载版本：

```c++
Foo sort() &&; //只有右值才能调用此函数
Foo sort() const &; //任何类型的Foo都能调用，const要写在&之前
//对于排序算法，右值版本可以直接对对象进行原地排序，左值版本必须先拷贝再排序。
```

注意：当定义多个具有同名、同参数列表的成员函数时，必须都加上引用限定符，或者都不加。？？？

```c++
Foo sort() &&;
Foo sort() const; //错误：必须加上引用限定符
```

