# 类

类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象依赖于接口（interface）和实现（implementation）的分离。

封装的优点：确保用户代码不会无意间破坏封装对象的状态；被封装的类的实现细节可以随时改变，而无需调整用户级别的代码，便于维护。

接口包含用户所能执行的操作；实现则包括类的数据成员、负责接口实现的函数体、定义类所需的各种私有函数。

### 访问控制与封装

- 定义在public说明符后的成员在整个程序内可被访问，即定义了类的接口。
- 定义在private说明符后的成员只能被类的成员函数访问，即封装了实现细节。
- 将外部函数声明在类内，并在其之前加上friend关键字，则外部函数可访问类内的非公开成员。

class和struct的区别在于：在第一个访问说明符之前定义的成员，class默认为private，而struct默认为public，即只是默认访问权限的不同。

接口（public）应该包括：构造函数、getter&setter。

### 类类型

一个类的成员类型不能是该类自己（因为此时类还没有被完全定义，编译器不知道该数据成员需要多少空间，递归构造也会爆栈），但可以是指向类的指针（因为已经声明过了）。

##### 成员的声明与定义

成员函数的声明必须在类的内部。

成员函数的定义（实现）则可以在类的外部，但必须与声明保持一致，且需要使用`::`。

在类外部访问类内成员需要使用作用域访问符`::`来标识。

定义在类内部的函数是隐式的`inline`函数。

一些用于处理类的辅助函数应被声明在与类同一个头文件中。

##### 隐式参数this

- 用`this`直接访问对象的成员：调用对象的成员函数时，编译器将对象的地址传递给成员函数的一个隐式形参this，成员函数通过this来访问调用它的对象。因此在成员函数中（包括构造函数）可以直接使用对象中的成员，而不需要this。
- `const this`：即它的类型是(T * const)，没有底层const使得不能用一个常量对象初始化this，同时也意味着不能限制成员函数对对象的修改操作。
- `const成员函数`：形如`fun(para_list) const {};`，给传入的this添加底层const，称为常量成员函数。常量对象不能调用普通成员函数，可以通过重载一个普通成员函数，使得`this`对象调用普通函数，`const this`对象调用常量成员函数。
- 可变数据成员：成员声明前加上`mutable`关键字，使得该成员永远不会是const，即使是const对象、const常量成员函数都可以修改可变成员的值。
- 返回this对象：返回类型声明为`T &`（左值引用），函数体内`return *this`。

### 构造函数

成员的初始化在构造函数的函数体执行之前完成，且它们在类中出现的顺序进行初始化。

构造函数没有返回类型，函数体内也无需return。

不能声明为const，因为构造函数在const对象的构造过程中可以向其写值。

##### 类内成员初始值

对象被默认构造时，按设定的初始值初始化/默认初始化成员。由于内置类型的默认初始化未定义，因此应该在类内为内置类型成员设定初始值，即对内置类型采用值初始化（如：`int a = 0; `或`int a{0};`）。

##### 默认构造函数

当没有定义任何构造函数时，编译器才会自动的隐式生成默认构造函数。当重载了其他构造函数时，编译器不会生成默认构造函数，因此应该自己定义默认构造函数（若不需要重新定义默认构造函数，则写成：`ClassName() =      default;`【C++11】）。

如果一个构造函数的参数列表全部提供了默认实参，则也是一个默认构造函数。

##### 隐式类型转换

转换构造函数：如果类类型定义了只接收一个参数的构造函数，则相当于定义了该参数类型向类类型转换的规则：当在一个需要类对象的上下文中（如作为实参、赋值号的右侧表达式），若使用其他类型，将自动调用对应类型匹配的构造函数，用它构造一个临时对象（注意临时对象不能赋值给引用，但可以被const引用）。

注意：只允许一步的隐式类型转换，隐式类型转换不具有传递性。

禁止隐式类型转换：在类内构造函数声明处使用`explicit`关键字，注意类外的定义处不许使用explicit。并且在调用拷贝构造`=`时也会禁止这种隐式类型转换。但`explicit`构造函数仍可以被`static_cast<ClassName>`强制调用该函数定义的转换规则，进行显式类型转换。

##### 初始值列表

在构造函数后加上`:`可以使用初始值列表，对成员进行值初始化。

```c++
ClassName(int i, int& ri) : mem1(i), mem2(ri), mem3(0) {};
```

对于成员是<u>const</u>、<u>引用</u>或是<u>未提供默认构造的类</u>，必须使用初始值列表初始化。

成员的初始化顺序取决于它们在类定义中出现的顺序，与初始值列表无关。

编译器不一定支持类内初始值，因此建议使用初始值列表来初始化成员。

另外，构造函数不应该轻易的覆盖掉类内的初始值。

##### 委托构造函数

【C++11】构造函数在初始值列表只有另一个构造函数，构造函数将参数和控制权传递给受委托的构造函数，由它代理执行初始化，直到受委托的构造函数初始化完毕并且执行完它的函数体后，控制权才交还给原来的构造函数。委托可以传递。

```c++
//非委托构造函数
ClassName(string s, unsigned cnt, double price) : mem1(s), mem2(cnt), mem3(price) {};
//其他构造函数全部委托给另一个构造函数
ClassNmae() : ClassName("", 0, 0) {};
ClassNmae(string s) : ClassName(s, 0, 0) {};
ClassNmae(istream& is) : ClassNmae() { read(is, *this); };
```

### 友元

若想要允许外部函数访问类的非公开成员，在类内再次声明外部函数，并在其之前加上friend关键字。（友元除了外部函数，还可以是外部类、外部类的成员函数。）

友元不是真的声明，只是指定了访问权限，因此也不是类的成员。

友元不具有传递性，友元的友元不是友元，即每个类控制自己的友元。

友元成员函数：声明时需要指明成员函数所属的类`::`。友元成员函数需要在这个类之前被声明（普通的外部函数、友元类不需要提前声明），同时由于友元成员函数需要访问类内成员，友元成员函数必须在这个类的定义之后定义。

一个类中的友元最好集中声明在一起。

这些外部函数的独立声明应该放在类的头文件中。友元削弱了封装。

### 类型成员

可以在类中定义类型来作为类型成员（using/typedef），设为public可以隐藏类型的具体实现。类型成员必须先定义，再使用，因此就应该放在类开始的地方！！

若在类外部需要用到该类型，需使用`::`作用域访问符。

### 静态数据成员

静态成员声明在类内部，与类关联，不与对象关联。

静态成员对象、函数可以定义在类外，在类外定义时不能再次加static。

静态成员常量定义在类内部，并限定const或constexpr；

静态成员变量在类的外部初始化与定义，且不设置类内初始值。

不需要创建对象，就能通过`ClassName::static_mem`直接访问（public的）静态成员对象、函数。

所有实例化的对象中不包含静态成员，共同使用同一个静态数据成员。

常量成员函数可以修改静态成员，因为并没有修改this对象。

静态成员函数不包含this指针，因此也不能被声明为const *this，函数体内也不能用this，自然也就不能访问实例对象中的成员（非静态对象）。【即static函数不能访问非静态对象，非静态对象可以访问静态对象】

静态数据成员的类型可以就是它所属的类类型，静态成员可以作为默认实参。

### 类的作用域

一个类的定义就是一个作用域；

定义在类外部的成员函数，使用作用域运算符，则剩余部分都在作用域之内，但由于函数的返回类型写在作用域运算符之前，不属于作用域，若返回成员类型，需要用`::`。

名字查找过程：先在使用名字所在块中寻找声明语句，且只考虑名字使用之前的声明，若找不到则查找外层作用域。

- 例：成员函数先在函数体内向前查找，再在整个类中查找，再在成员函数定义之前的作用域查找（想要绕开查找规则，可以使用作用域运算符）。

编译器先编译成员的声明，直到类全部可见后才编译函数体，即最后定义成员函数。

##### 【设计模式】const成员函数返回*this

前面讲到返回类型为引用，返回值为*this的函数。

这样的函数可以将一系列操作连接在一条表达式中，如obj.append().append()。

要实现这种连续操作，必须保证this的在传递过程中不变为const（返回类型、隐式形参this都不能为const）。但是显然有些函数并不对对象进行修改，应该限定为const。

解决方法：

1. 将该函数进行重载，定义两个公共成员函数：一个是非常量函数，另一个常量函数的返回类型、隐式形参this都为const。
2. 它们都调用同一个返回类型为void的私有const常量成员函数：所有具体的操作都由这个私有函数来实现。
3. 公共的接口函数只是调用私有函数完成具体操作以及返回*this。