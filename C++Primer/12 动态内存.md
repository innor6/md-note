# 动态内存

对象生存期：

- 全局对象：程序启动时分配，程序结束时销毁
- 局部自动对象：进入定义所在程序块时创建，离开块时销毁
- 局部static对象：第一次使用之前分配，程序结束时销毁
- 动态分配的对象：由程序代码显式的创建，只有显式地释放时才会被销毁。

【c++11】标准库定义了两个智能指针类型，来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动的释放它。

三个内存池：

- 静态内存：保存局部static对象、类static数据成员、定义在任何函数之外的变量
- 栈内存：保存定义在函数内的非static对象
- 堆：存储动态分配的对象，即在程序运行时分配的对象

分配在静态内存和栈内存的变量由编译器自动创建和销毁，而堆中的动态分配对象由程序代码显式的销毁。

三种使用动态内存的原因：

- 程序不知道自己需要使用多少对象（如：容器）
- 程序不知道所需对象的精准类型
- 程序需要在多个对象间**共享数据**（如：多个对象都有一个`shared_ptr`成员）

## 1 动态内存与智能指针

<memory>

C++中通过`new`和`delete`管理动态内存。C++11新标准库提供了两种智能指针类型来安全、方便地管理动态对象，负责自动释放所指向的对象：`shared_ptr`和`unique_ptr`，前者允许多个指针指向同一个对象，后者则独占所指向的对象。还定义了一个弱伴随类`weak_ptr`，是一种弱引用，指向`shared_ptr`所管理的对象。

### 1.1 直接管理内存

使用`new`和`delete`可以直接管理动态内存，前者调用构造函数，后者调用析构函数。

##### 分配动态内存

```c++
int *pi = new int; //默认初始化，内置类型int的初始值未定义
int *pi = new int(); //值初始化为0，对内置类型意义重大，对自定义类无意义
int *pi = new int(1024); //调用构造函数
vector<int> *pv = new vector<int>{0,1,2,3}; //列表初始化
//分配const对象必须进行初始化
const string *pcs = new const string; //string有默认构造，可以隐式初始化
const int *pci = new const int(1024); //int必须显式初始化
```

由于内存是无名的，`new`无法为其分配的对象命名，而是返回一个指针。在动态分配的对象时，记得进行初始化。

##### 内存耗尽的情形

```c++
int *p = new int; //如果分配失败，抛出std::bad_alloc异常
int *p = new (nothrow) int; //分配失败不抛出异常，而是返回一个空指针
```

<new>中定义了`bad_alloc`和`nothrow`。

##### 释放动态内存

通过`delete`一个指针来销毁所指向的动态对象，并释放内存。要求指针必须指向动态分配了的内存或是空指针。释放非new分配的内存，或将同一指针释放多次的行为是未定义的。

`delete`指针后，只是释放了动态分配对象和内存，指针本身还保存着无效的地址值，成为了悬空指针，建议在释放指针后将`nullptr`赋值给它。但即使这样做，仍然无法避免其他指向相同对象的指针成为悬空指针。

也就是说，在指针传递的过程中，始终要注意各个指针的状态、作用域以及关联的动态内存的状态。既要避免内存泄漏，又要避免使用悬空指针。

##### 常见问题

1. 忘记delete内存导致<u>内存泄露</u>。当局部指针离开其作用域后被销毁，所指向的动态内存就永远无法被释放了。
2. 访问已经释放掉的对象，即<u>悬空指针</u>。释放后将指针置空可以避免这种错误。
3. 同一块内存的<u>二次释放</u>。当两个指针指向同一动态分配对象时可能发生，导致内存空间破坏。

### 1.2 shared_ptr类

##### 引用计数

每个`shared_ptr`都有一个引用计数，当指针被拷贝、初始化另一个共享指针、作为参数、作为返回值传递时，计数器递增；当共享指针被赋予新值、销毁（局部共享指针离开它的作用域）时，递减。一旦计数器变为0，共享指针会自动调用`delete`销毁对象，释放内存。

##### 初始化

智能指针是模板类，初始化需要提供所指对象类型：

```c++
shared_ptr<T> p; //空指针，if(!p)
unique_ptr<T> p; //空指针
make_shared<T>(args) //*根据args调用T的构造函数，并返回shared_ptr
shared_ptr<T> p(new int()); //普通指针->共享指针
shared_ptr<T> p(q);  //普通指针->共享指针
shared_ptr<T> p(p2); //共享指针->共享指针
shared_ptr<T> p(u);  //独有指针->共享指针，并将u置空
//重载删除器d的版本
shared_ptr<T> p(q, d);
shared_ptr<T> p(p2, d);
```

##### 重置

```c++
p.reset(); //释放所指对象
p = p2;               //共享指针->共享指针
p.reset(q);           //普通指针->共享指针
p.reset(u.release()); //独立指针->共享指针，并将u置空
p.reset(q,d); //使用可调用对象d代替delete来释放内存
```

一种用法是与`p.unique()`共同使用，当所指对象被多个`shared_ptr`共享时，可以分配一个新的动态对象，并对其修改：

```c++
if (!p.unique())
    p.reset(new string(*p)); //若不是对象的唯一用户，则分配一个新对象，作为原对象的拷贝
*p += newVal; //现在知道对象只有一个用户，可以修改对象的值
```

##### 其他操作

```c++
*p
p -> men
p.get(); //返回一个普通指针
swap(p,q);
p.swap(q);
//shared_ptr独有的操作：
auto p = make_shared<T>(args) //构造一个shared_ptr
shared_ptr<T> p(p2) //拷贝构造，要求类型匹配,unique_ptr不能拷贝
p = p2
p.unique() //若没有与p共享对象的指针，则为true
p.use_count() //返回与p共享对象的指针数量，速度慢，调试用
```

##### 不要混用智能指针与普通指针

1. 智能指针与普通指针属于不同类型，不能相互隐式转换、赋值。
2. 一旦将普通指针“托管”给了智能指针后，不应该再使用普通指针来访问对象，因为对象可能已经被智能指针自动销毁了。
3. “伪共享”的共享指针：不要用对象的普通指针分别创建多个独立的`shared_ptr`，这样无法实现“共享”指针，因为它们各自使用不同的计数器，从而无法知道所指对象真正的被引用次数，这可能导致对象的提前释放、释放后再次访问、二次释放等问题。应该用一个共享指针创建另一个共享指针。
4. `p.get()`返回普通指针：应该谨慎使用，所以永远不要用`p.get()`来初始化另一个智能指针，或者为另一个智能指针赋值。只有在确定代码不会delete该指针对象的情况下才使用`p.get()`。

##### 智能指针与异常

函数的退出有两种可能，正常结束或发生异常，无论哪种情况，局部对象都会被销毁。

对于使用普通指针管理的动态内存，如果在`new`之后、`delete`之前发生了异常，且异常没有在该函数中被捕获，则退出函数、销毁作为局部变量的指针，所指向的内存永远都无法释放，内存泄露。

如果使用智能指针，就可以避免这种问题，因为当发生异常退出函数时，局部智能指针被销毁，自动检查引用计数并释放对象内存。

##### 管理其他资源

默认情况下，智能指针用于管理动态内存，并通过`delete`销毁对象。

事实上，智能指针还可以用来管理其他系统资源，特别适用于这样一类问题：

> 不是所有的类都定义了良好的析构函数，能够清理对象使用的资源。有一些类，需要为其分配资源，但又没有定义析构函数来释放这些资源，必须通过调用其他函数显式的释放资源。
>
> 特别是那些为C和C++两种语言设计的类，由于C只有struct，通常要求用户显式地释放所使用的任何资源。
>
> 例如“网络连接”就是一种资源，需要显式的调用“关闭连接”函数才能释放连接资源，如果发生异常，退出函数，可能导致连接无法正常的关闭。

这类问题和“直接管理动态内存中，需要显式的调用`delete`来释放对象和内存资源”非常相似。

实现的方法：

1. 对要管理对象取地址，传递给智能指针
2. 自定义释放资源的函数，代替默认的`delete`

```c++
shared_ptr<T> p(& myClass, myDelete);
```

无论是程序正常退出，或是发生异常，智能指针都可以很好的管理好系统资源。

##### 智能指针使用规范

推荐的构造智能指针方法如下，可以直接用new作为参数可以避免普通指针的出现：

```c++
shared_ptr<T> p(new int());
auto p = make_shared<T>(args) //构造一个shared_ptr
unique_ptr<T> u(new int());
```

为了避免内存泄露、悬空指针、二次释放的问题，使用规范如下：

- 智能指针默认管理动态内存，不要传给他其他内存对象
- 不要混合使用普通指针与智能指针
- 一旦将普通指针“托管”给了智能指针后，不应该再使用普通指针来访问对象
- 对于`shared_ptr`要记住共享引用，对于`unique_ptr`要记住所有权转移
- 不使用相同的普通指针初始化（或reset）多个`shared_ptr`，会导致引用计数不一致
- 不delete `p.get()`返回的普通指针
- 不使用`p.get()`初始化或reset另一个指针
- 如果使用`p.get()`返回的指针，记住当最后一个对应的智能指针被销毁后，该指针变为无效
- 对于`u.release()`返回的普通指针，要么交给智能指针，要么记得手动显式释放对象
- 如果使用智能指针管理不是new分配的动态内存，记住传递给它一个删除函数

具体原因请参考“智能指针与普通指针”部分所述。

### 1.3 unique_ptr类

`unique_ptr`“拥有”它所指向的对象，某个时刻只能有一个`unique_ptr`指向一个给定的对象，当`unique_ptr`被销毁时，对象也被销毁。

unique_ptr独有的操作：

```c++
unique_ptr<T> u; //空指针
unique_ptr<T> u(q); //普通指针->智能指针
unique_ptr<T, D> u; //D为删除器类型
unique_ptr<T, D> u(d); //d为自定义删除器，代替默认的delete

u.release(); //智能指针->普通指针，u置空，但不销毁对象
u.reset(q); //释放旧对象，并管理一个新对象
u.reset(); //置空
u.reset(nullptr); //置空
u = nullptr; //置空
```

##### 初始化

unique_ptr没有类似`make_shared`这样的操作，只能通过new返回的普通指针进行初始化：

```c++
unique_ptr<T> u1(new int());
```

##### 不支持拷贝或赋值

unique_ptr单独拥有所指对象。

```c++
unique_ptr<T> u2(u1); //错误：unique_ptr单独拥有对象，不支持拷贝
u2 = u1; //错误：不支持赋值
```

##### 所有权的转移

虽然unique_ptr不支持拷贝或赋值，但可以通过`release`或`reset`将所有权从一个（非const的）unique_ptr转移到另一个unique_ptr：

```c++
//p.release()放弃对象的控制权，并返回它的一个普通指针，注意不是释放对象
unique_ptr<T> p1(p2.release());
//p.reset(q)会释放旧对象，并从一个普通指针获得新对象的控制权
p1.reset(p3.release());
```

由于`release`返回了普通指针，为了安全管理内存，要么交给智能指针，要么记得手动显式释放对象。

另外，当unique_ptr被作为函数的返回值时，由于它先被销毁，又被传递，所以这种“拷贝”是允许的。

> 较早标准库中有一个auto_ptr类，具有部分unique_ptr的特征，但不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr。

##### 重载删除器

unique_ptr管理删除器的方式与shared_ptr不同，需要提供删除器类型（有些类似于重载关联容器的比较操作）：

```C++
unique_ptr<T, decltype(myDelete)*> u(q, myDelete); //D为删除器类型
```

### 1.4 weak_ptr

weak_ptr是一种不控制对象生存期的智能指针，它指向shared_ptr管理的对象，但不会影响到shared_ptr的引用计数，因此也不影响shared_ptr释放对象，是一种“弱共享”。

weak_ptr通过shared_ptr来初始化：

```c++
weak_ptr<T> w;
weak_ptr<T> w(sp); //指向shared_ptr管理的对象
w = p; //p可以是shared_ptr或weak_ptr
```

不能使用weak_ptr直接访问对象，因为对象可能已经被释放，必须调用`lock`：

```c++
w.reset(); //置空
w.use_count(); //返回shared_ptr的引用计数
w.expired(); //检查指针是否失效，如果shared_ptr的引用计数为0，则返回true
w.lock(); //用于返回对应的shared_ptr，若对象已经释放（引用为0）则返回空的shared_ptr
```

weak_ptr的一种用途是用于传递shared_ptr共享对象，并检查其有效性（这是普通指针无法做到的）：

```c++
shared_ptr<T> sp = w.lock(); //共享对象，若对象已经释放，lock返回空指针
if (sp) { sp与w成功共享对象 }
if (!sp) { 对象已经释放，抛出异常 } 
```



## 2 动态数组

`new`和`delete`一次只能分配或释放一个对象，而像vector、string容器在重新分配内存时，需要一次性为多个元素分配连续内存。有两种方法可以实现：

1. C++定义了另一种`new`表达式语法，可以分配并初始化一个对象数组；
2. 标准库包含了一个`allocator`类，允许将分配和初始化分离。`allocator`类通常提供更好的性能和更灵活的内存管理能力。

很多应用中都没有直接访问动态数组的需求，当一个应用需要可变数量的对象时，通常采用更简单、快速、安全的——vector（或其他标准库容器）。使用容器的类可以使用默认版本的拷贝、赋值和析构操作，而分配动态数组的类则必须定义自己版本的操作，在拷贝、复制以及销毁对象时管理所关联的内存。

### 2.1 new和数组

##### 分配动态数组

使用方括号`[]`指明要分配对象的数目，数目必须为整型，但不必为常量：

```c++
//分配动态数组，返回指向第一个元素的指针
int *p = new int[get_size()]; //元素默认初始化，元素个数不必为常量
int *p = new int[10](); //元素值初始化为0
int *p = new int[10]{0，1，2}; //列表初始化前三个元素，剩余元素值初始化
int *p = new int[0]; //合法：可以分配空动态数组，返回合法的非空指针，但不能解引用
//初始化列表中数目必须小于等于动态数组元素数目
//不能在括号中使用初始化列表，不能使用auto

typedef int arrT[42];
int *p = new arrT; //使用类型别名
```

##### 动态数组不是数组

分配一个动态数组，实际上并没有生成一个“数组对象”（即使使用了类型别名），而是得到一个元素类型的指针，甚至连size都是不知道的。因此不能对动态数组调用`begin`、`end`、范围for语句。

遍历数组动态：

```c++
int *p = new int[n];
for (int *q = p; q != p + n; ++q) //遍历数组
```

##### 释放动态数组

```c++
delete [] p; //指针p指向第一个元素
```

记得要手动释放动态数组，元素按逆序销毁。

##### 智能指针与动态数组

可以使用unique_ptr来管理动态数组：

```c++
unique_ptr<T[]> u(); //类型中记得加[]
unique_ptr<T[]> u(p); //普通指针p指向动态数组
u[i]; //下标运算
u.release(); //自动用delete[]销毁指针
```

指向动态数组的unique_ptr不支持成员访问（`.`和`->`运算符），因为并没有真的数组对象，但可以通过下标运算符来访问每一个元素。

shared_ptr不支持直接管理动态数组，如果想要使用shared_ptr，需要提供删除器：

```c++
shared_ptr<int> sp(new int[10], [](int*p) { delete[] p; });
sp.reset(); //使用自定义的lambda释放数组
```

shared_ptr没有定义下标运算，且智能指针本身也不支持算术运算来进行指针偏移。因此为了访问动态数组中元素，必须用`get`获取一个普通指针，然后用它访问数组元素。

### 2.2 allocator类

new有一些灵活性上的局限，如将内存分配和对象构造组合在了一起，delete将对象析构和内存释放组合在了一起。在分配一大块内存时，立刻完成所有的对象构造可能会造成不必要的浪费。

##### 分配内存

allocator类可以实现分配内存与构造对象的分离，定义在<memory>中，它是模板，所以需要提供要分配对象的类型，根据类型来确定需要分配的内存大小以及对齐位置。

```c++
//分配可以保存n个T类型对象的原始的、未构造的内存
allocator<T> alloc;
T* const p = alloc.allocate(n); //用const p指针保存动态数组的位置，用于后面的释放
```

##### 构造对象

在分配好的内存中构造对象：

```c++
alloc.construct(p, val); //将val拷贝到在指针所指位置
alloc.construct(p, args); //【C++11】在p所指位置，args传递给T的构造函数创建对象
```

构造对象实例（假定T类型为string）：

```c++
auto q = p;  //q指向下一次构造的位置
if (q != p + n) //判断内存释放耗尽
    alloc.construct(q++, 3, 'c')； //创建了一个"ccc"对象，q++指向最后构造元素之后的位置
```

管理内存的三个重要指针：

- 指向分配内存的首元素p
- 指向下一块空内存q（即最后构造元素之后的位置）
- 指向分配内存末尾之后的位置p+n

三个指针构成了两组首尾迭代器，分别表示对象数组和分配的内存空间。

指针间可以进行算术运算，获取距离。

##### 销毁对象

销毁全部元素的代码：

```c++
while (q != p) alloc.destroy(--q); //逆序，对每个元素调用它们的析构函数
for_each(p, q+n, [this](T& e) { alloc.destory(&e);}); //顺序，利用for_each遍历析构
```

##### 释放内存

销毁元素后可以释放全部内存：

```c++
alloc.deallocate(p, n); //释放全部内存，p、n必须与分配内存时的值相同！
```

##### 拷贝和填充未初始化内存的算法

标准库提供了可以在未初始化内存中创建元素的算法：

```c++
//拷贝算法返回一个指针，指向最后一个构造的元素之后的位置
uninitialized_copy(b, e, b2); //将[b,e)中元素拷贝到从b2开始的未构造原始内存中
uninitialized_copy_n(b, n, b2); //从b开始的n个元素拷贝到b2开始的内存中

uninitialized_fill(b, e, t); //在[b,e)指定的原始内存中填充元素t的拷贝
uninitialized_fill_n(b, n, t); //从b开始的原始内存中填充n个元素t的拷贝
```