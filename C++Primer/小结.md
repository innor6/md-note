##### 常见错误

通过指针访问对象成员要用`->`

一个语句中创建两个指针变量时，两个变量名前都要加`*`。

`inline`用于函数声明，而不是定义。

`static`用于声明，而不是定义。？

`explicit` 只能用于类内部的构造函数声明。

`virtual` 用于类内成员函数声明，而不是类外定义。

##### 关于类

const成员函数、const对象只能调用const成员函数。

static成员函数只能访问static成员/函数（也不能使用this）。

const数据成员只能在构造函数的初始化列表中进行初始化，不能在构造函数的函数体中初始化。

static成员属于类，不属于对象。只能在类外定义（即使私有），类外定义时不用再写static。

普通成员函数中的static变量，只在对象调用该函数时才被共享。

构造、析构函数不能有返回类型。

- 拷贝构造函数的其中一个参数必须为&或const &，参数类型绝对不能为自己的类类型（循环调用）。

转型构造函数只有一个参数。

析构函数没有参数，不能重载。

malloc、free不会调用构造、析构，而new、delete会。

可将默认构造、拷贝构造设为私有成员，来禁止默认构造、对象传值拷贝。可用explicit禁止转型构造函数定义的隐式转换。

friend可以声明在类的任意地方。

##### 关于继承

默认为私有继承。

派生类不继承构造、析构函数。

通常在派生类的构造函数的初始化列表中显式调用基类的构造函数，否则调用基类的默认构造，若基类没有默认构造，则出错。

构造函数执行顺序：先基类（多继承则按继承的顺序），再自己数据成员的构造函数（按在类中的声明顺序），最后自己的构造函数体。（先父母，后客人，最后自己。析构相反。）

虚基类：用于菱形继承，使得只包含一个虚基类子对象，中间的类保存一个指向虚基类子对象的指针。在继承列表中使用`virtual`。此时构造顺序中，最先构造虚基类。对虚基类构造的调用来自于最派生类，而中间类会跳过对虚基类的构造调用，即虚基类的构造只被调用一次。

除了赋值操作符（=）之外，基类中所有被重载的操作符都将被派生类继承。操作符以顶层函数实现时， 在他的参数表必须中包含一个类对象（以区分是用户定义的）。 

`::`，`.`，`.*`，`:?`不能重载；`[]`，`()`，`=`，`->`必须为成员函数。

使用顶层函数进行重载的一个优点就是：非对象操作数可以出现在操作符的左边

运算符函数 operator=()必须被重载为类的非静态的成员函数，而且重载后的operator=()不能被继承。

【分清“类”和“对象”的访问权限】

基类的私有成员仅对于基类函数可见，派生类只能间接通过公有接口访问。基类的保护成员对于派生类的成员函数可见。

在派生类的private中使用`using BC::fun();`，可使继承来的公有函数fun()变为派生类的私有函数。用这种方法，可以隐藏继承来的公有接口，避免被外部调用。

派生类中的同名成员会隐藏对应基类的成员。可用::访问基类被隐藏的成员。

私有继承指：使基类的公有成员、保护成员全部成为<u>派生类的私有成员</u>（保护继承就是全部变为派生类的保护成员），即只能被派生类的成员函数访问，而不能通过对象访问。

##### 多态

一个函数在内存中起始的地址称为这个函数的入口地址。多态就是将函数名称动态地绑定到函数入口地址的运行期绑定机制。

用`virtual`修饰基类的虚成员函数。派生类中该函数都是虚函数。

多态三个条件：

1. 继承体系结构

2. 继承体系中包含一个同签名的虚成员函数（被隐藏则不行）

3. 基类的指针、引用调用虚成员函数

（如果编译时已经静态绑定，则一定不会多态）

C++使用vtable（虚成员函数表）来实现虚成员函数的运行期绑定。系统将某一函数名绑定到虚成员函数表中的特定入口地址。

构造函数不能是虚成员函数，但析构函数可以。

（要建立一个对象，必须拥有完全的信息。需要知道要建立的对象的具体类型。因此，对构造函数的调用不可能是虚拟的。）

静态成员函数不可以是虚成员函数。

一旦派生类的虚函数不能覆盖基类的虚函数，就会产生虚函数的遮蔽。要产生多态效果，必须为二个类定义具有相同函数签名的虚函数。

纯虚函数：在基类中定义一个虚函数，函数声明的结尾加上=0，该基类为抽象基类，不能实例化。

dynamic_cast仅对多态类型有效，目的类型必须为指针、引用，即必须有虚函数。

构造函数中调用的虚函数没有多态。

模板类型并不具有隐式的类型转换，例如在int与float之间、float与double之间等的隐式类型转换。



##### map&set

```
set.find(value) == set.end() //表示不含该元素
set.insert(value)
set.size();
```





##### 栈&队列

顺序容器适配器：

**stack**：<u>deque</u>、list、vector、string

**queue**：<u>deque</u>、list（要求能pop首部）

**priority_queue**：<u>vector</u>、deque（要求随机访问线性表）

```c++
/*适配器支持的通用操作*/
a.empty()
a.size()
a.swap(b)
swap(a,b)
```

**栈**

```c++
stack<int> stk;    //创建栈
stk.push(item);
int item = stk.top(); //返回栈顶元素，但不弹出
stk.pop();         //弹出栈顶元素，但不返回它的值

stk.emplace(args);
stack<string,vector<string>> stk(vec); //使用非默认的底层实现（vector）创建栈
```

**队列**

<queue>

```c++
queue<int> q;
q.push(item);  //入队
q.pop();       //出队
int i = q.fornt(); int j = q.back();  //queue
int k = q.top();  //priority_queue
q.emplace(args);
priority_queue<ListNode*, vector<ListNode*>, compare> q; //第三个模板参数为比较谓语（compare是类，包含一个public的重载的operator()比较函数，若进行>比较，则生成升序序列，出队的是最小值）
```

##### 文件流

<fstream>

```c++
ifstream in;
in.open("file.txt");
in>>…;
getline(in,buff);
in.close();
```

