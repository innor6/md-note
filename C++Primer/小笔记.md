# 小笔记

`size_t`和`size_type`都是属于`unsigned int`，表示范围取决于机器，前者用于表示内置数组的下标，后者用于表示`vector`，`string`等容器的下标。

自定义类中的`print`函数返回类型通常设为`ostream&`。

迭代器解引用`*iter`和`iter->menber`不要弄错，后者是解引用后访问内部成员。

程序设计：要完成的任务、操作——用到的数据结构——

`p.get()`：智能指针中使用，用于获取对应的普通指针

`c.at(index)`：容器中使用，进行下标访问，关联容器用key

`*a.p`是先访问成员，再解引用

定义类时，是否需要定义拷贝控制成员，可以看是否含有指针、引用、const数据成员。



检查一个unsigned类型变量u大于0，小于n：`if(u > n) /*超出范围*/`，因为负数会变为非常大的数，而变量的正常值又小于n。

关于引用：

对一个C风格常量字符串的引用，其类型为`const char(&)[n]`，其中n为总长度+1。



时间间隔

```c++
//#include<cstdlib>
#include <ctime>

{
    clock_t begin = clock();
    ...
    clock_t end = clock();
    double secs = double(end - begin) / CLOCKS_PER_SEC;
}

{
    time_t now = time(0); //获取当前时间,从1970至今的秒数
    cout << ctime(&now) << endl; //转换为文本
}
```



随机数

```c++
#include<time.h>
srand(time(0)); //随机数种子
int r = rand()%100; //i = [0,99]
double d = rand() / double(RAND_MAX); //取得0～1之间的浮点数
```







**decltype()**：当表达式为引用、指针解引用、双层括号的变量时，即左值时，返回类型为引用。

```c++
int i = 42, *p = &i, &r = i;
decltype(r) b;   // int&
decltype(r+0) c; // int，利用加法操作可以去除引用
decltype(*p) d;  //错误：表达式为解引用时，推导类型为引用int&，d必须初始化
decltype((i)) e; //错误：双层括号一定推导为引用，因为(i)不再是变量，而是一个表达式，而(i)是一个左值表达式，所以返回引用，e必须初始化
```



**nullptr**：不要用NULL表示空指针：（C++11）

1. NULL在c中为`(void*)0`，在c++中为`0`（c++不支持将void*指针转换为其他指针）；而nullptr是语义上的“空指针”。
2. 对于重载函数，null作为实参可能具有二义性，即null既可以匹配到int形参，也可以匹配到void*形参；
3. 当作为模板参数，进行类型推导时，NULL可能会被推导为其他类型，而nullptr一定推导为指针。

##### 参数类型：

const对象只能调用它的const成员函数

参数类型的选择：

如果函数不修改实参，则使用常量引用`const T&`；（如：const string&）

如果需要修改实参对象，则使用引用`T&`；

如果是内置类型且不修改，则直接值传递。

##### 类

对象中只有数据成员（除了static成员）。

函数都保存在类类型中。

##### OOP

公有成员：接口

私有成员：隐藏的实现细节

受保护成员：希望被派生类访问的细节