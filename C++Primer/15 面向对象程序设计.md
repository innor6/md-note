# 面向对象程序设计

OOP的核心思想：数据抽象、继承、动态绑定。

- 数据抽象：类的接口与实现分离；
- 继承：定义相似的类型，并对其相似关系建模；
- 动态绑定：在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象。

## 继承

通过**继承**（inheritance）联系在一起的类构成一种层次关系。层次关系的根部有一个**基类**（base class），其他类则直接或间接地从基类继承而来，称为**派生类**（derived class）。

基类负责定义在层次关系中所有类共同拥有的成员，每个派生类定义各自持有的成员。

### 派生类

##### 派生类列表

派生类使用派生类列表来指出它从哪些基类继承而来：

```c++
class D : public A, protected B { }; //派生类D继承于基类A和B
```

继承的多个基类间用逗号分隔，每个基类前可以有访问说明符`public`、`protected`、`privated`。

注意：

1. 派生类列表只能出现在类的定义处，不能出现在声明处。
2. 如果要继承某个基类，该基类必须已经定义。
3. 类不能继承自己。

##### 阻止继承

可以在类后加上关键字`final`，使它无法作为基类：

```c++
class NoDerived final { }; //NoDerived不能作为基类
```

##### 派生类的成员

派生类继承基类的所有成员，因此一个派生类的对象包含：

- 派生类自己定义的（非静态）成员
- 从基类继承来的成员

C++标准没有规定这些成员在内存中如何分布。

对于基类定义的静态成员，在整个继承体系中只存在唯一的实例。

对于链式继承，如C派生于B，B派生于A，则C既直接继承了B的成员，又间接继承了A的成员。

##### 派生类的构造函数

每个类分别控制自己的成员初始化过程。

构造一个派生类对象时，先初始化基类部分的成员，然后再按声明顺序依次初始化派生类的成员。

初始化基类部分时，通常显式的委托给基类的构造函数（若不委托则使用默认构造）：

```c++
class Derived : public Base {
public:
    Derived(int a,int b) : Base(a,b) { } //将参数传递给基类的构造函数，由它初始化基类部分
};
```

##### 到基类的类型转换

由于派生类继承了基类的所有成员，因此派生类可以被<u>当成基类</u>对象使用：

```c++
Base b;    //基类
Derived derived; //派生类
Base *ptr = &derived; //基类指针可以指向一个派生类
Base &ref = derived;  //基类的引用可以绑定到一个派生类
```

1. 这种类型转换只对指针和引用有效，类类型之间不能这样转换；
2. 不允许对`private`继承的基类进行类型转换；（即受到可访问性的限制，见“访问控制”）
3. 和其他的类型转换一样，编译器会隐式地执行这种派生类到基类的转换。

**动态类型**：当我们使用一个基类的<u>指针/引用</u>时，编译阶段无法确定它指向基类or派生类，只要到真正运行时才知道指针/引用所绑定的实参类型是什么。

反过来，基类不能转换为派生类，因为编译器无法确定这种转换在运行是否安全。

1. 如果在基类中有虚函数，可以使用`dynamic_statci`请求类型转换，调用派生类版本的虚函数；
2. 如果已知基类向某个派生类的转换是安全的，则可以`static_cast`来强制转换。



### 虚函数

基类中有两种成员函数：一种是希望派生类进行**覆盖**（override）的函数；另一种是希望派生类直接继承。

对于前者，通常将其定义为**虚函数**（virtual），基类的<u>引用或指针</u>在调用虚函数时使用**动态绑定**，即在程序运行时才确定调用者（this）的动态类型，选择对应版本的虚函数。

注意：一定要是指针/引用，一定要是虚函数，才会动态绑定。

关键字`virtual`只能出现在类内部声明处，而不能用于类外定义。

基类通常都应该定义一个虚析构函数，即使它什么都不做。

##### 派生类中的虚函数

基类中的虚函数，在派生类中隐含地也是虚函数（可省略`virtual`关键字）。

派生类如果没有覆盖虚函数，则从基类直接继承。

派生类中虚函数的形参、返回类型要与基类版本保持一致。例外：当返回自己类型的指针时，基类返回`B*`，派生类返回`D*`是允许的，但是要求D到B的类型转换是可访问的。

如果派生类中的虚函数，使用了与基类虚函数不同的形参列表，也是合法的，此时两个函数相互独立，基类版本的虚函数没有被覆盖。

##### 覆盖控制

【C++11】在派生类的虚函数后加上`override`关键字，可以让编译器检查是否使用了正确的参数列表：

```c++
struct Base { virtual void f(int) const; };
struct Derived { void f() const override; }; //编译错误：虚函数的参数列表与基类不匹配
```

对基类的虚函数使用`final`可以指定该函数不能被覆盖：

```c++
struct Base2 { virtual void f(int) const final; };
struct Derived2 { void f(int); }; //编译错误：定义为final的函数不能被覆盖
```

`override`和`final`说明符出现在形参列表（包括const或引用修饰符）、尾置返回类型之后。

##### 默认实参

虚函数可以有默认实参，如果某次函数调用使用了默认实参，则实参值由本次调用的静态类型决定。

即，如果使用一个基类的指针/引用，绑定了一个派生类对象，则在调用虚函数时，使用基类（静态类型）的默认实参，但调用派生类（动态类型）版本的虚函数。

因此基类和派生类的虚函数最好使用相同的默认实参。

##### 避免动态绑定

虚函数的调用使用动态绑定，但有时不希望使用动态绑定。

直接使用作用域运算符`::`来调用指定的函数可以避免动态绑定：

```c++
baseP->Base::fun(); //不论指针指向什么对象，强制调用基类的虚函数fun()
```

使用的情形：当一个派生类的虚函数需要调用的基类版本虚函数时，直接使用`Base::fun()`，让基类版本完成共同的操作，然后由派生类版本执行一些特定的工作。千万不要在派生类的虚函数中调用自己版本的虚函数，这会导致无限递归。

##### 纯虚函数&抽象基类

在一个虚函数声明语句的分号之前写上`=0`，使其为**纯虚函数**。

```c++
struct Base { virtual int fun(int) = 0; } //声明一个纯虚函数，此函数无意义
```

纯虚函数无需定义，但形参列表和返回类型仍然需要。也可以为其提供定义，但必须定义在类外。

含有（或直接继承）纯虚函数的类称为**抽象基类**，负责定义接口。

抽象基类不能创建对象。

一种设计方法是，设计一个抽象基类，在基础上派生出继承体系。但是由于抽象基类不能生成对象，因此再用一个普通类将其封装，其中含有一个指向抽象基类的智能指针成员。利用虚函数的动态绑定特性来执行特定派生类的操作。



### 访问控制

每个类分别控制着自己的成员对于派生类来说是否**可访问**（accessible）。

某个类对其继承而来的成员的访问权限受到两个因素影响：

1. 基类中成员的访问说明符
2. 派生类在派生列表中的访问说明符

##### 受保护的成员

`public`成员：接口，可以被所有对象访问。

`private`成员：实现细节，可以被类内成员、友元访问。

`protected`成员：实现细节，可以被类内成员、友元、派生类内成员、派生类的友元访问。

注意：派生类成员、派生类的友元只能访问<u>派生类对象中的基类部分</u>的`protected`成员，而不能访问基类对象的`protected`成员（`b.prot_men`、`Base::prot_men`），因为它不是基类的友元。

##### 受保护的继承（★）

根据派生类成员的组成，我们可以把派生类分成两部分：基类部分、派生类自己的部分。

当在派生列表中使用`public`、`private`、`protected`时，我们可以看作是将“基类部分”看作一个整体，作为派生类的一个成员。

如果没有在派生列表中声明继承方式，则class默认为`private`继承，struct默认为`public`继承。

因此在判定派生类的基类部分成员的可访问性时，需要进行两层检查（★）：

1. 派生类的“基类部分”整体是否可访问；（派生类对象只能访问public；而派生类成员可以访问所有部分）
2. “基类部分”中的某个成员是否可访问；（public都可以访问；protected成员可以被派生类内成员访问）

或者直接将两层访问说明符相加，即可得到基类部分成员的访问权限。

使用成员的用户有两种：

- 类的实现者（派生类内成员、派生类的友元）

  派生访问说明符对其没有任何影响。因为无论怎样继承，基类的private始终是无法访问的，而public、protected成员就算被继承为private，依然可以被派生类内成员、派生类的友元所访问。

- 普通用户（使用派生类对象、派生类的派生类对象）

  其访问权限受到影响，派生类对象只能访问派生类中的public部分的，不能访问private和protected，不同继承方式将会导致不同的可访问范围。

##### 派生到基类的转换

这种类型转换能否进行，会受到可访问性的影响。

一言蔽之：**如果派生类可以访问基类的公共成员，则派生类向基类的类型转换是可行的。**

例：基类Base和派生类Derived，以及派生类Derived的派生类DD

- 对于派生类对象d，只有派生类是public继承时，才能进行类型转换。（因为只有public继承才能使派生类对象访问基类部分的成员）
- 对于直接继承，无论如何继承，派生类Derived的成员函数、派生类的友元的函数体中，`this`永远可以进行向<u>直接基类</u>的类型转换。（派生类内成员一定可以访问基类的公有成员）
- 对于间接继承，Base-Derived-DD，派生类DD的成员和友元，同上永远可以向直接基类Derived转换；但之后能不能进一步转换为Base，取决于Derived对Base公有成员的继承方式，如果是public、protected继承，则可以，若是private继承，则不行。

```
Base *p = &d; //派生类对象的类型转换
void memfun(Base &b) { b = *this; } //类内成员函数体中的类型转换，对应后面两点
```

##### 友元

友元关系不能传递和继承，每个类各自声明自己的友元。

类内函数能访问哪些成员，则友元就能访问哪些成员。

特别的，基类Base的友元可以访问基类的所有对象，甚至可以访问派生类中的基类部分：

```c++
//基类
class Base {
    friend class Pal;
    friend void f2(Derived d);
private:
    int prv = 1;
protected:
    int prot = 2;
};
//派生类
class Derived : public Base { };
//友元类
class Pal {
    void f1(Derived d) { cout << d.prv << d.prot << endl; } //可以访问基类成员
};
//友元函数
void f2(Derived d) { cout << d.prv << d.prot << endl; } //可以访问基类成员
```

##### 改变个别成员的可访问性

派生类列表中的访问说明符决定了全部“基类部分”成员的继承方式，但是可以在派生类中使用`using `声明，改变其中个别成员的继承方式。这些成员如何继承取决于`using`声明语句之前的访问说明符。

```c++
class Base {
public:
    size_t size() const { return n; }
protected:
    size_t n = 0;
};

class Derived : private Base { //私有继承
public:
    using Base::size; //size()成员对派生类的来说为public
protected:
    using Base::n; //n成员对派生类来说是protected
};
```

这样，虽然对基类进行私有继承，但是基类部分的个别成员（size()、n）分别被public、protected继承。

派生类只能为它可以访问的名字提供`using`声明，所以基类中的private成员是不能使用`using`的。



### 类的作用域

每个类定义自己的作用域，在作用域内我们定义类的成员。

存在继承关系时，派生类的作用域嵌套在基类的作用域内。

如果一个名字在派生类作用域内无法解析，则编译器到外层的基类作用域中寻找该名字的定义。

##### 在编译时进行名字查找

对象、引用、指针的静态类型决定了该对象的哪些成员是可见的，也就是说在编译阶段，我们已经（通过程序代码）知道将要调用的函数的名字、要访问的变量的名字，它们能否被访问是根据静态类型来决定的。由于虚函数的名字是出现基类作用域中的，所以此函数也可以被调用。

说明：如果一个派生类对象被绑定到一个基类指针，则通过指针，我们只能使用（静态类型）基类中已有的名字，即代码被编译成访问基类的成员、调用基类的函数；如果这个成员在<u>编译时的静态类型中是虚函数</u>，则随后在运行时进行动态绑定，调用对应版本的函数。

##### 名字冲突与查找

与其他作用域一样，派生类也能重用定义在外部基类作用域中的名字，此时内层作用域（派生类）中的名字将会隐藏外层作用域的名字。

这是因为**名字查找先于类型检查**，当在内层派生类作用域中找到名字后，编译器就不再查找了，然后进行类型匹配，若无法匹配则直接报错。

- 派生类的（数据、函数）成员会隐藏同名的基类成员。

- 但是可以使用作用域运算符`::`来使用一个被隐藏的成员。

（基类虚函数可能被派生类同名的普通函数隐藏，详见P550）

> 除了覆盖继承而来的虚函数之外，派生类最好不要重新定义其他在基类中的名字！！

##### 覆盖重载的函数

一旦内层作用域定义了一个同名函数，则外层作用域的所有同名重载函数都被隐藏。

有时希望只覆盖外层作用域的某个重载函数，由于外部同名函数全被隐藏，需要将所有外部函数覆盖一遍，很不方便。可以使用`using Base::fun`改变外部成员的可访问性（见访问控制），由于`using`不需要指定形参列表，外层所有的重载函数都被添加到派生类的作用域中，而不是被隐藏，此时只需定义派生类特有的函数，对派生类没有重新定义的重载版本的访问实际上是对using声明点的访问。



### 构造函数与拷贝控制

##### 虚析构函数

继承关系中，<u>基类总是需要析构函数，且要定义为虚函数</u>。

因为，`delete`一个动态分配对象的指针时，会执行析构函数。如果`delete`的时一个基类指针`*Base`，则实际绑定的对象可能是一个派生类，显然我们希望能够正确的销毁派生类，因此要利用虚函数的动态绑定特性，调用派生类版本的析构函数。

定义了析构函数的基类不必遵守三/五法则，即不一定需要定义拷贝和赋值操作。

如果一个类定义了析构函数，则编译器不会为这个类合成移动操作。

##### 合成的拷贝控制

基类和派生类的自动合成的拷贝控制：对类本身成员依次进行初始化、赋值、销毁操作；它们还会调用直接基类中对应的操作（默认构造/合成的赋值/虚析构函数），对直接基类部分的成员进行初始化、赋值、销毁。（要求直接基类中的操作可以被访问，且不是删除的）：

也就是说，派生类想要实现某个拷贝控制的操作，必须确保其直接/间接基类都定义了这个操作。

1. 如果基类的默认构造、拷贝构造、拷贝赋值、析构函数是不可访问/删除的，则派生类中对应操作也为删除；
2. 如果基类中的析构函数是不可访问/删除的，则派生类中合成的默认构造、拷贝构造是删除的；
3. 编译器不会合成删除的移动操作。

##### 派生类的拷贝控制成员

1. （自定义的）拷贝/移动构造函数、赋值运算符，需要负责拷贝/移动包括基类部分在内的整个对象。

   ！！由于它们默认使用基类的默认构造函数初始化基类部分，因此应该显式的在初始值列表中调用基类的对应的拷贝/移动构造函数。赋值运算符也应在函数体内先调用基类的赋值运算符。

2. 析构函数只需负责销毁派生类自己分配的资源，派生类对象的基类部分和其他普通成员一样会自动调用自己的delete销毁。

##### “继承”的构造函数

【C++11】派生类能重用其基类定义的构造函数：

```c++
class Derived : public Base {
public:
    using Base::Base; //继承直接基类Base的构造函数
};
```

`using`声明语句通常只是令某个名字在当前作用域可见，但当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数：

```c++
Derived(parms) : Base(parms) { } //自动生成多个像这样的构造函数
```

显然这样的构造函数只是用直接基类的构造函数初始化基类部分，然后对自己的类内成员默认初始化。

1. `using`声明构造函数后，继承下来的版本的访问级别（public、private、protected）、explicit、constexpr都会继承。
2. 如果基类构造函数含有默认实参，则会在派生类生成多个版本的构造函数，没有默认实参的版本、将参数表中有默认实参的形参去掉的版本（隐式填了默认实参）。
3. 如果基类含有多个构造函数，则全部继承。但如果派生类中自己定义的构造函数与基类的具有相同参数列表，则不继承。
4. 默认、拷贝、移动构造函数不会被继承，而是编译器为派生类自动合成。



### 容器与继承

容器存放继承体系中的对象时，通常采用间接存储。

因为容器要求其中的元素类型相同，当一个类对象被`push_back`放入容器时，是将对象<u>拷贝</u>到容器中：

1. 若以派生类为元素类型，则无法保存基类对象；
2. 如果以基类为元素类型，则进行拷贝的时候，调用的是基类的拷贝构造，导致派生类部分被“截断”。

因此，容器中的元素类型应该为基类的（智能）指针。

当容器类型为`<shared_ptr(Base)>`时，即使`push_back`一个派生类的智能指针`shared_ptr(Derived)`，它也会自动转换为基类的智能指针。

