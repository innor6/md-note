# 模板与泛型编程

面向对象编程与泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于，OOP能处理类型在程序运行之前都未知的情况，而泛型编程中在编译时就能获知类型了。

模板是C++泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。

## 1 定义模板

##### 函数模板

```c++
template <typename T> //模板参数列表,不能为空
int compare(const T &v1, const T &v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

当调用一个函数模板时，根据实参的类型来推断**模板参数T**的类型。

编译器用推断出的模板参数来**实例化**（instantiate）一个特定版本的函数。

函数模板可以声明为`inline`或`constexpr`，关键字写在模板参数列表之后，返回类型之前。

##### 类模板

类模板的模板参数`T`不能自动推断，需要在实例化时指出，如`vector<int>`。

实例化的类型为`ClassName<T>`，不同的实例属于不同类型，它们之间不会有特殊的访问权限。

成员函数如果定义在类模板之外：

```c++
template <typename T> //需要关键字和模板参数列表开头
ret_type ClassName<T>::mem(parm_list) { ... } //作用域访问应该为ClassName<T>::mem
```

成员函数（包括静态函数）只有当程序用到时才进行实例化。这使得即使T不能完全支持模板的所有操作，也能对其进行实例化。

当处于一个类模板的作用域中时，其模板类名`ClassName<T>`可以简写为`ClassName`。

友元是模板的情形：

```c++
//在类或模板类内声明友元，T是模板类的模板参数
template <typename X> friend class Pal; //Pal实例化后的所有类都是友元，Pal不需要提前声明
friend class Pal2<T>; //只有实例类Pal2<T>是友元，Pal2需要提前声明
```

【C++11】允许将模板参数T作为友元，从而使得实例化类的内部成员可以被实际的T类访问。

【C++11】允许为模板类定义类型别名：

```c++
template<typename T> using twin = pair<T,T>;
twin<stirng> authors; //author是一个pair<string,string>
```

##### 模板参数

1. 类型参数：在类型参数前必须使用关键字`typename`或`class`，两者意思相同。

   如：`<typename T, class U>`，T和U用于表示类型。

2. 非类型参数：表示一个常量值，需要指明它的具体类型。实例化时推断出它的具体值。

   如：`template <unsigned N> int fun(const char (&p)[N]) { }`接受一个长度为N的字符串数组。

   非类型参数可以为整型、指针、引用，其中整型的实参必须为常量表达式，指针/引用的实参为static对象。

模板参数的名字会掩盖外部typedef定义的类型，且不能在模板内重新声明参数的类型。

模板参数的名字在声明和定义中不必相同。

使用`typename`+作用域访问符来访问类型T的成员：

```c++
template <typename T>
typename T::value_type fun(const T& c) //函数fun接受一个容器c，返回一个容器T类的value_type类型
{
    return typename T::value_type();
    //也可以在模板内用using value_type = typename T::value_type;声明类型别名
}
```

【C++11】允许为函数和类模板提供默认实参：

```c++
//用户可以提供自己的比较操作
template <typename T, typename F = less<F>> //可调用对象F的默认模板实参为less<T>
int compare(const T& v1, const T& v2, F f = F()) //函数参数f的默认实参为F()
{
    if (f(v1, v2)) return -1;
    if (f(v2, v1)) return 1;
    return 0;
}
```

类模板如果有默认模板实参，实例化时需要用空`<>`表示使用默认实参：`Temp<> a`。

##### 成员模板

类或模板类的成员函数可以为模板，称为成员模板，不能是虚函数。

对于模板类的模板成员，显然两者具有不同的模板参数；也因此在模板类外定义模板成员时，需要写两次`template`和模板参数列表。

成员模板和普通的函数模板一样，自动推断类型。

##### 显式实例化

在大系统中，当多个独立编译的源文件使用了相同的模板，且提供了相同的模板参数，隐式实例化会导致额外的开销。

【C++11】可以显式的在某个文件中实例化一个模板，即使这个模板没有被用到。模板类的所有成员都会被实例化。需要提供模板参数的实参，且这个类型能够用于模板的所有成员。

```c++
//declaration模板参数部分要用实参替换
extern template /*declaration*/  //实例化声明
template /*declaration*/         //实例化定义
```

实例化声明：`extern template`告诉编译器，该模板的实例化定义位于程序的其他位置，不必本文件生成实例化代码：

```c++
//在某个文件中使用extern声明
extern template int compare(const int&, const int&);
extern template class Blob<string>;
```

实例化定义：当编译器遇到一个实例化定义，为其生成代码：

```c++
//在另一个文件中显式地定义，给出了模板参数T的类型
template int compare(const int&, const int&);
template class Blob<string>;    //类实例化会实例化所有的成员！即使没有被用到（所以不能有模板成员？）
```

由于编译器一旦遇到使用模板的代码就进行实例化，因此extern声明必须出现在任何使用该实例版本的代码之前。

其他关于非显式的实例化：

编译过程中，如果类模板被作为类型，用于声明一个形参、返回类型、定义一个指针/引用变量，并不会实例化生成代码；只有在用到模板的<u>对象</u>时（或用到模板的函数被调用时），才会发生实例化。

##### 效率与灵活性

以`shared_ptr`和`unique_ptr`为例，

- 前者删除器的类型在运行时才知道，因此需要间接调用删除器，调用时需要一个跳转操作，但是不规定类型使得用户重载删除器更方便；

- 后者删除器类型是模板参数的一部分，在编译时已经知道删除器成员的类型，可以在编译时就实例化删除器，甚至直接内联，没有运行时的额外开销。

##### 编写泛型代码的原则

模板程序应该尽量减少对实参类型的要求，编写<u>类型无关</u>的代码：

- 形参的声明：
  - 函数形参的一般为`const T&`。（保证函数可以用于不能拷贝的类型）
  - 实参为指针/引用时，可直接令形参类型为T。
  - 实参为数组时，用`const T (&arr)[N]`，表示含N个T类型元素的数组。
- 类型支持的操作：
  - 函数体的条件判定仅使用`<`比较运算。（不需要支持`>`，甚至应该使用`less`模板）
  - 遍历容器的for循环中使用`!=`而非`<`（大部分迭代器只定义了`==`和`!=`）

##### 编译过程

编译器遇到模板的定义时，不生成代码；当给定了模板参数类型，需要实例化出模板的特定版本时，才生成代码。

调用一个函数时，函数只需已被声明；使用一个类类型对象时，类定义必须可用，但成员函数不必已经出现。因此将类定义、函数声明放在头文件；普通函数和类的成员函数的定义放在源文件。

模板则不同，由于实例化的机制，模板的头文件通常同时包括声明、定义。

- 模板的提供者：实例化时，保证模板的定义、类模板成员的定义都是可见的；

- 模板的使用者：保证实例化时，函数、类型、类型关联的运算符的声明都是可见的。



## 2 模板实参推断

对于函数模板，编译器通过函数调用中实参的类型，来推断模板参数。

##### 不允许类型转换

一次函数调用中，实参被传递用于初始化形参，对于函数模板的模板参数，编译器通常不对实参进行类型转换，而是直接生成新的模板实例。

允许的类型转换：

- const转换：顶层const被忽略，如果形参是引用/指针，没有底层const的实参-->有底层const。
- 数组或函数指针：如果形参不是引用，则数组实参-->指向首元素的指针，函数实参-->函数指针。

不能用于函数模板的转换：

- 算术转换
- 派生类向基类转换
- 用户定义的转换

例：

```C++
template <typename T> void fun(T, T); //函数接受两个相同类型的参数
int i = 0;
long l = 0;
const long cl = 0;
fun(i, l);  //错误：根据第一个实参推断T为int，第二个实参必须为int，不能进行long到int的算术转换
fun(l, cl); //错误：推断T为long，第二个实参不能实现从const long到long的转换
```

##### 显式实参

有时编译器无法推断模板参数，有时希望允许用户自己指定模板参数。特别是当返回类型与参数列表中任何类型都不相同时。

```C++
template <typename T1, typename T2>
T1 sum(T2, T2);             //返回类型T1无法推断
auto val = sum<long>(1, 1); //在尖括号中显式指定T1的类型为long
auto val2 = sum<long, int>(1.5, 1.5); //显式指定了T2为int,允许类型转换！
```

显式模板实参通过尖括号`<>`给出，按<u>从左至右</u>顺序依次指定模板参数列表中的参数。

显式指定的模板实参，允许进行类型转换！

##### 尾置返回类型

有时，返回类型取决于函数的参数类型，但是参数列表出现在返回类型之后，编译器需要遇到参数列表之后，才能使用参数的名字。

```c++
template <typename It>
??? & fun(It beg, It end) { return *beg; } 
//返回类型可以用decltype(*beg)获取，但在???处编译器还没有遇到beg这个名字

//改用尾置返回类型
template <typename It>
auto fun(It beg, It end) -> decltype(*beg) { return *beg; } //返回一个引用
```

##### 类型转换模板

标准库<type_traits>

```c++
//例：remove_reference<int&>::type模板可以去除引用，type成员返回int
//对于上面的例子中，迭代器解引用只能返回元素的引用，我们可以利用该模板取出引用
template <typename It>
auto fun(It beg, It end) -> 
    remove_reference<decltype(*beg)>::type { return *beg; } //返回一个元素的拷贝而不是引用
```

每个模板都有一个type成员，表示转换后的类型，如果不能进行转换，则type就是模板参数类型本身。

![16.1 type_traits](C:\Users\64589\Documents\Tepora\C++Primer\16.1 type_traits.png)

