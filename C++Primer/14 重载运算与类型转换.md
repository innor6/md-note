# 重载运算与类型转换

当运算符被用于类类型的对象时，C++允许我们为其指定新的含义。

重载运算符是函数，也包含返回类型、参数列表、函数体。

重载运算符的参数数量与该算符作用的算子数量一样多。对于类中定义的重载运算符，由于重载运算符的第一个算子（左侧运算对象）已经作为隐式参数的this传入，因此显式的参数列表比实际的算子数量少一个。

除了`operator()`，其他重载运算符不能含有默认实参。

重载运算符要么本身是类成员，要么至少含有一个类类型的参数，即不能重新定义内置类型的运算符含义。

重载运算符的优先级、结合律无法改变。

不能被重载的四个运算符：`::`、`.*`、`.`、`?:`

调用运算符的两种方式：

```c++
data1 + data2; //通过类型匹配，间接调用
operator+(data1, data2); //等价的函数调用，如果是成员运算符，则需要用访问运算符'.'
```

##### 不应该被重载的运算符

- 重载运算符本质是函数，因此运算对象的求值顺序规则无法应用到重载运算符，**与、或、逗号**运算符的运算对象求值顺序规则无法保留下来。`&&`和`||`的重载版本也无法保留内置的短路求值属性，两个对象总是会被求值。
- C++语言已经定义了**逗号、取地址**运算符用于类类型对象时的特殊含义，因此也不建议重载他们。

##### 重载运算符or定义普通操作

- 如果某些操作在逻辑上与运算符相关，则适合被定义成重载运算符。

- 只有当操作的含义对使用者是明晰的时候才重载运算符，否则容易产生二义性。

- 如果类内含有算术运算符或者位运算符，最好提供他们的复合赋值运算，如定义了+，则最好也定义+=。

##### 成员or非成员

- 赋值（=）、下标（[ ]）、调用（( )）、成员访问箭头（->）必须是成员。
- 复合赋值运算（+=）一般来说应该是成员，但非必须。
- 改变对象状态的运算符，如递增、递减、解引用，通常是成员。
- 具有对称性的运算符（任何一端都可能需要类型转换），如算术（+、=）、相等性（!=）、关系（<）、位运算符（>>），通常是非成员函数。

注意：非成员的重载运算符想要访问类内数据，需要声明为友元。

## 1 重载运算符

##### 输入输出运算符

输入输出运算符必须是非成员函数，因为IO类属于标准库，而不是自定义类。

```C++
ostream& operator<<(ostream& os, const T& t); //参数2为对象的常量引用
istream& operator>>(istream& is, T& t); //参数2为非常量
```

- 通常`<<`负责打印对象的内容，而不进行格式控制，如不应该在函数体内打印换行符，留给用户去控制。

- 输入运算符`>>`必须处理读取失败的情况（用`if(is)`判断），并从错误中恢复，如将对象置为合法状态。

- 有时`>>`需要做更多数据验证工作，如能正常读入，但数据不符合规范，可以置`failbit`，标志错误。

##### 算术和关系运算符

算术和关系运算符函数通常允许多左侧或右侧运算对象进行类型转换，如`int + double`的情形。

一般不改变算子状态，所以形参为常量引用。

算术运算符计算得到一个新值，返回该局部变量的副本。

如果定义了复合赋值运算符（+=），则最好用复合赋值来定义对应的算术运算（+）：先拷贝lhs，然后将rhs+=到副本上，返回副本。（普通的加法操作需要构造临时对象，而+=运算则不需要）

相等运算符：

- 如果需要判断两个类对象是否相等，则最好定义`==`和`!=`。
- `==`应该具有传递性。
- 如果定义了`==`，则也应该定义`!=`，直接调用`==`并取反。

关系运算符：

一般选择定义`<`，因为一些容器算法会用到。`>`可以`return rhs < lhs;`。

要求满足：

1. 存在唯一一种逻辑可靠的`<`定义（例如一个类在不同的条件下有不同的比较规则，则不应该定义<）
2. 如果类还定义了`==`，则两个互相不`<`的类对象，他们一定得相等`==`

##### 赋值运算符

定义在类内。

需要考虑自赋值和异常安全。

赋值基本流程：先拷贝右侧对象得到副本（自赋值），然后析构左侧对象，将副本数据拷贝给左侧（或直接返回副本）。

拷贝控制中已经介绍了拷贝赋值、移动赋值运算符，赋值运算符`=`的右侧还可以接受其他类型的参数。

接受初始化列表作为参数：

```c++
T& T::operator=(initializer_list<string> il);
```

可以通过`il.begin()`、`il.end()`获取迭代器来访问初始化列表的内容，也可直接用范围for遍历容器。

由于参数是初始化列表，不用考虑自赋值的情形。

复合赋值运算符：

```c++
T& T::operator+=(T&);
```

##### 下标运算符

表示容器的类一般会定义`[]`。

`[]`通常返回引用，这样可以作为左值或右值，出现在赋值运算符的任意一端。

通常定义两个版本：

```c++
value_type& T::operator[](size_t n);
const value_type& T::operator[](size_t n) const; //常量对象返回常量的引用
```

下标操作要检查访问位置是否越界。

##### 递增和递减运算符

迭代器类中通常会实现`++`和`--`。

需要定义前置和后置版本。

前置：

前置运算符应该返回递增后对象的引用。

```c++
T& T::operator++();
```

递增运算符有时需要先判断递增操作是否安全，然后再进行递增。

后置：

为了与前置版本区分，后置版本多接受一个匿名的int形参，编译器自动提供值为0的实参，但代码中不使用它。

```c++
T T::operator++(int){
    T ret = *this;    //先记录对象的原始状态
    ++*this;          //用前置版本递增
    return ret;       //返回副本
}
```

后置运算符返回对象的原值，而非引用。

##### 成员访问运算符

迭代器类、智能指针类常常用到解引用`*`和箭头运算符`->`。

```c++
value_type& T::operator*() const;  //一般是解引用了类内的某个成员
value_type* T::operator->() const {
    return & this->operator*();    //将->的工作委托给*
}
```

一般解引用和箭头运算符不改变对象状态，设为常量函数。

重载的`->`必须返回类的指针，或者是类（要求该类重载了`->`）：

即对于一个类对象a，表达式`a->men`，首先调用对象a的成员函数`->`，若返回类型是对象（而非引用），则调用该对象的重载`->`，递归，直至有一个重载`->`返回了指针，则调用内置的箭头运算符，访问该指针所指对象的成员men。

## 2 调用函数运算符

重载的`()`的类，可以像函数一样被调用。由于类还储存了状态，所以比普通函数更灵活。

一个类可以定义多个`()`，需要在参数数量、参数类型上有所区别。

定义了`()`的类的对象称为函数对象，类中的数据成员可以用于保存函数的状态。

函数对象常常用作泛型算法的实参，作实参时要加上`()`。

### 2.1 lambda是函数对象

编写了一个lambda表达式后，编译器将该表达式翻译成为一个匿名类的匿名对象。

默认情况下，lambda不能改变它捕获的变量，因此默认产生的类中的`()`是const成员函数。如果lambda被声明为可变（参数列表后加上`mutable`），则`()`就不是const函数了。

关于捕获：

如果是引用捕获，则无需在类中将其存储为数据成员。

如果是值捕获，则需要在类内建立对应的数据成员，同时定义类的构造函数，令其使用捕获的变量来初始化数据成员。（因此在mutable的lambda中修改值捕获的变量，只是修改了类的成员，而不影响外部函数中的局部变量）

lambda表达式产生的类不含默认构造、赋值运算符、默认析构；是否含有拷贝/移动构造函数，取决于要捕获的数据成员类型。

相较于类，lambda表达式更适合用于使用频率较低，且函数较简单的情形。

### 2.2 标准库定义的函数对象

标准库定义了一组模板类，表示算数运算符、关系运算符、逻辑运算符，每个类分别定义了执行对应名字操作的调用运算符。如`plus`的`()`定义了`+`操作。

由于是模板，可以指定算子的类型，生成一个函数对象，函数对象的参数数目与算子数目相同。

下表所列类型定义在<functional>中：

| 算术             | 关系                | 逻辑              |
| ---------------- | :------------------ | ----------------- |
| plus<Type>       | equal_to<Type>      | logical_and<Type> |
| minus<Type>      | not_equal_to<Type>  | logical_or<Type>  |
| multiplies<Type> | greater<Type>       | logical_not<Type> |
| divides<Type>    | greater_equal<Type> |                   |
| modulus<Type>    | less<Type>          |                   |
| negate<Type>     | less_equal<Type>    |                   |

常用于替换算法中的默认运算符，如：

```c++
sort(vec.begin(), vec.end(), greater<string>()); //将升序排序（<）改为降序排序
```

值得注意的是，这些函数对象对指针同样适应，如：

```c++
vector<string *> vec;
sort(vec.begin(), vec.end(), [](string* a,string* b) {return a < b;}); //错误：vec中的指针可能指向不同的容器，比较两个无关的指针将产生未定义的行为
sort(vec.begin(), vec.end(), less<string*>()); //正确：可以比较指针的内存地址
```

关联容器使用`less<key_type>`对元素排序，因此可以将指针作为set或map的key而无需声明less。

### 2.3 可调用对象与function

可调用对象：函数、函数指针、lambda表达式、bind创建的对象、重载函数调用运算符的类。

不同类型的可调用对象可能有同一种调用形式（call signature）：即拥有相同的返回类型和实参类型。

```c++
//下面定义三种具有相同调用形式的不同可调用对象
int add(int i, int j) { return i+j; }
auto mod = [](int i,int j) { return i%j; }
struct divide { int operator()(int i, int j) { return i/j; } };

map<string, int(*)(int,int)> binops; //value为函数指针的，接受两个int，返回一个int
binops.insert({"+", add}); //只有普通函数add可以被加入到映射中
```

三种可调用对象中，虽然拥有相同的调用形式`int(int,int)`，但由于mod、divide有自己的类型，与binops中的value类型不匹配，因而不能被加入此map中。

解决方案：

【C++11】<functional>中定义了`function`，它存储一个指向可调用对象的指针：

```c++
//T为可调用对象的调用形式，如<int(int,int)>，左侧为返回类型，括号内为实参类型
function<T> f;          //空function
function<T> f(nullptr); //空function
function<T> f(obj);     //f中存储可调用对象obj的副本
if (f)   //当f含有可调用对象时，返回true
f(args)  //调用f中的对象，参数是args
//function<T>的成员类型
result_type             //可调用对象的返回类型
argument_type           //实参的类型（T只有一个实参时）
first_argument_type     //第一个实参的类型（T有两个实参）
second_argument_type    //第二个实参的类型（T有两个实参）
```

利用它可以将不同类型、但有相同调用形式的可调用对象转化为同一类型`function<T>`。

```c++
function<int(int,int)> f1 = add;
function<int(int,int)> f2 = divide();
function<int(int,int)> f3 = [](int i,int j){ return i*j };
map<string, function<int(int,int)>> binops; //将不同类型的可调用对象统一为function类型
binops = { //这里的列表初始化应该是发生了类型转换
    {"+", add},             //普通函数指针
    {"-", std::minus<int>}, //标准库对象
    {"/", divide()},        //重载调用运算符的类对象成员
    {"*", f3},              //function
    {"%", mod}              //命名了的lambda对象
};
binops["+"](10,5);  //调用add(10,5)
```

`function`重载了自己的`()`，会将接受的实参，传递给自己存储的可调用对象。

##### 重载的函数与function

不能（直接）将重载函数的名字传入function类的对象中：

```c++
int add(int,int);
string add(string,string);
function<int(int,int)> f = add; //错误：哪个add？
```

？？？function自己不能在赋值的时候进行类型匹配到正确的函数吗？？？

为了消除二义性，可以使用函数指针、lambda表达式：

```c++
int (*fp)(int,int) = add; //fp指向int(int,int)版本的add
function<int(int,int)> f = fp;
function<int(int,int)> f = [](int i, int j) { return add(i,j); };
```

## 3 类型转换

定义类型转换的方式：

1. 使用非显式（explicit）的转换构造函数，只接受一个实参，实现实参类型到类类型的转换。
2. 使用类型转换运算符，实现从类类型到其他类型的转换。

这些类型转换规则会被隐式的自动调用，需要注意二义性问题，或者将其声明为`explicit`的。

自定义的类型转换规则可以与标准类型转换规则一起使用。

### 3.1 类型转换运算符

类的一种特殊的成员函数，负责将一个类类型的值转换成其他类型。

```c++
operator type() const;  //type为要转换的类型
```

- 类型转换运算符没有显式的返回类型，也没有形参，且必须定义为类的成员函数。（返回类型已经由type指定，隐式类型转换不需要形参）
- 类型转换通常不应该改变待转换对象的内容，因此一般为const。
- type可以为任意类型（除了void），只要该类型能作为函数的返回类型（即不能为数组或函数类型）。

注意：自定义的类型转换规则是会自动执行的，有时可能会令我们意外，因此应该小心地重载，尽量不要定义存在误导性的类型转换，要么应该将此规则声明为`explicit`的。

##### 二次类型转换

每次类型转换只能进行一次用户自定义的类型转换，即不允许二次类型转换。

但是，用户定义的类型转换可以发生在标准类型转换（即内置类型转换）之前或之后，并与其一起使用，如下面的`mi + 3.14`就是发生了`MyInt -> int -> double`的两次类型转换。

```c++
class MyInt {
public:
    MyInt(int i = 0) : val(i) {}         //int -> MyInt
    operator int() const { return val; } //MyInt -> int
private:
    std::size_t val;
};

MyInt mi = 3.14; //double -> int -> MyInt
mi + 3.14;  //mi先转换为int，然后发生内置类型转换变为double
```

##### 显式类型转换

【C++11】新标准引入了显式（explicit）类型转换运算符，关键字`explicit`只能用在类内声明处。

```c++
explicit operator type() const;
```

此时不会再自动发生隐式类型转换，必须显式的使用强制类型转换`static_cast<T> (a)`。

例外，当表达式被用作条件时，编译器会自动地应用显式类型转换：

- if、while、do、for、? : 的条件部分
- 逻辑运算符 !、||、&&的运算对象

向`bool`类型转换通常用在条件部分，因此`operator bool`一般定义成`explicit`。

### 3.2 避免有二义性的类型转换

如果类中包含一个或多个类型转换，必须确保在类类型和目标类型之间只存在唯一一种转换方式，避免二义性。

两种情况下会产生<u>多重转换路径</u>：

1. 两给类提供了相同的类型转换：A类定义了接受B类型的构造函数，B类定义了转换为A的类型转换运算符。

   隐式类型转换不知道使用哪一方，此时必须显式的调用转换构造函数、类型转换运算符。

2. 类定义了一组转换规则，而这些转换源/目标的类型本身可以通过其他的类型转换联系在一起。特别是算术运算符，最好只定义一个与算术类型有关的转换构造函数or类型转换运算符。

   如：定义了接受int和double的转换构造，则实参为long类型时，需要二重类型转换，由于都不是最佳匹配，编译器没法区分两种转换的优先级别。但是当实参为short时，标准类型转换将优先转换为int。

一言蔽之：除了显式地向bool类型的转换以外，应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。

出现二义性的情形：

定义了相同的类型转换、转换目标为内置类型时存在多重转换路径、不同版本重载函数的参数类型可以从同一种实参类型转换得到。

在调用重载函数时，如果需要额外的标准类型转换，则该标准类型转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。否则标准类型转换的优先级被忽略：

```c++
struct D { D(int); };
struct E { E(double); };
void fun(const D&);
void fun(const E&);
fun(10);  //二义性错误：两个重载的fun都可以被调用，注意这里会忽略标准类型转换的影响
```

调用函数时，类型匹配优先级：

1. 精准匹配
2. 转换为const
3. 类型提升
4. 转换为算术或指针类型
5. 转换为类类型
