# 并发

同时存在、发生、进行的事情。

多个执行流可以不按照特定的顺序执行，而得到正确的结果。



所有应用程序实际上都是系统调用，而 syscall 需要考虑并发：

- 每个进程的地址空间是独立的，互不影响；

- 操作系统中的对象是被进程所共享的。



线程

- 共享：代码、全局变量（数据、堆）
- 独享：堆栈、寄存器
- 线程间指令的执行顺序是不确定的（non-deterministic）

每个线程虽然都独立地拥有一定大小的堆栈，但这只是标记了一下虚拟的内存地址，而不是真的分配了内存空间。



### 多线程编程

##### POSIC Threads 线程库

pthread_create：创建一个线程，从给定的入口地址开始执行

pthread_join：等待某个线程执行结束，并执行回调函数



查看每个线程的堆栈大小、范围：

1. 先用`[CMD] &`后台执行程序
2. 使用`pmap [PID]`查看内存地址映射

可以看到每个线程的栈空间之间都有一个4K的不可访问页面，因此指针出界后产生segment fault。



多线程的困难：

- 原子性的丧失：处理器中断/并行

- 可见性的丧失：处理器指令允许操作不同数据的指令乱序执行

- 顺序的丧失：编译器优化（volatile关键字声明某个变量相关的操作不能被优化）

  1. 假设是单线程程序
  2. 程序中不冲突的读写操作的顺序可能会交换
  3. 重复读、重复写时，重复的操作可能会被删去

看起来“原子”的一条指令可能并不原子

多处理器下cache和内存的一致性问题



peterson算法可以实现两个线程的互斥：

1. 全局变量x=0，y=0，turn
2. 线程1：x=1，turn=Y，while(y && turn == Y) 死循环，x=0
3. 线程2：y=1，turn=X，while(x && turn == X) 死循环，y=0

检验方法：状态机（有向图），看不同的执行顺序会不会进入不安全的状态。



### 进程互斥

线程的基本操作：

- 线程中的本地计算（寄存器、堆栈上的修改）
- load，读共享内存，“只看”
- store，写共享内存，“闭着眼睛修改”

不能保证load和store的原子执行，带来了并发编程的困难。



**指令：test-and-set**

```
reg = load(lock)
if (reg == 0) 
store(lock, 1)
```

- 原子性：load和store不会被打断
- 顺序：处理器执行的乱序不能越过原子操作
- 多处理器之间的可见性：若原子操作A发生在B之前，则A之前的store对B之后的load可见



**指令：xchg**

交换寄存器和内存地址中的值。

```
reg = load(x)
store(x, XX)
```



**实现互斥：自旋锁**

假设全局有一个锁，利用xchg，交换全局变量和自己的变量

1. 若交换后得到锁，进入临界区，最后再xchg返还锁
2. 若交换后未得到锁，进入循环，不断交换（自旋），直到

```c
int locked = 1;	// 1表示锁，位于公共内存中
void lock() {
	while (1) {
		int ret = xchg(&locked, 0);	// 尝试获取锁，并放回一个0
        if (ret == 1) break; // 获得了锁
    }
}
void unlock() {
	xchg(&locked, 1);
}
```



**CISC指令：Load-Reserved / Store-Conditional (LR/SC)**

Load Reserved：load(x)，在处理器上标记内存地址x为“reserved”，一旦有其他处理器在x上写入了，或中断，则标记被清除。

Store Conditional：尝试store(x)，若标记“reserved”还在，则store可以成功。

LR和SC之间可以加任意的本地计算操作，当SC失败时，重复执行中间操作，同样可以实现互斥。



**数据竞争（data race）**

- 两个并发执行的操作访问同一段内存
- 至少有一个写操作
- 其中没有原子操作间隔。

则两个操作的先后执行顺序是不确定的，产生未定义的行为。

避免方法：所有线程间共享的变量都被同一把互斥锁保护。





### 操作系统上的互斥

单核处理器上，导致线程发生切换的唯一来源就是**中断**。

现在考虑多处理器的情况：

**观察：获得自旋锁的线程（处理器）不应被中断**

因为如果线程中断，切换到另一个线程，它也试图获取这个自旋锁，则由于锁未被释放，线程会把分配到的宝贵的CPU时间全都用于自旋，直到再次被中断。（毫无意义的并发）

**自旋锁实现互斥：关中断 + 自旋：在进入临界区之前（上锁前）关中断**

中断的目的：线程等待IO浪费CPU时间，引入中断来切换进程，实现并发，提高CPU使用率；

根据上面的观察，既然并发无意义，那就关闭中断，让线程独占CPU执行。

实现细节：

- 先关中断，再获得自旋锁
- 先释放锁，再打开中断
- 嵌套上锁的情形：
  - 第一次lock前（lock数==0），保存当前的中断状态，关闭中断
  - 最后一次unlock后（lock数==0），恢复之前保存的中断状态，从而保证最后一次unlock时才会打开中断
- 只关闭单个CPU的中断，否则如果一个CPU的线程进入临界区，就关闭所有CPU的中断，会使得其他CPU都失去了并发，性能损失大。





关中断 + 自旋 ：只适合于保护一段较短的临界区

- 持有锁期间，本CPU不能被中断
- 其他CPU如果需要该锁，也会进入自旋



对于较长的临界区，如独占访问磁盘进行IO，关中断使得系统性能降低，同时磁盘IO本身就是需要处理器中断的。

**解决方案：互斥锁**

```c
void mutex_lock() {
	while (1) {
		int ret = xchg(&locked, 0);	// 尝试获取锁，并放回一个0
        if (ret == 1) 
            break; //获得锁
        else 
            enqueue_and_yield(); //获取锁失败,则进入等待队列，并把CPU让给其他线程
    }
}
//unlock时，检查等待队列，唤醒之前等待的线程
```











