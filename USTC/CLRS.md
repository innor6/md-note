2.1 算法基础

循环不变式证明算法正确性：（类似数学归纳法）

- 初始化：循环的第一次迭代前，它为真。
- 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
- 终止：循环终止时，不变式得到一个有用的性质

2.2 算法分析

单处理器计算机模型：随机访问机（Random Access Machine），包含算术指令、数据移动指令、控制指令，每条指令所需时间为常量ci（可能不相等）。

一般算法需要的时间与输入的规模同步增长，通常把一个算法的运行时间描述成其输入规模的函数。

往往集中于只求最坏情况的运行时间，因为它是算法运行时间的上界，某些算法经常出现最坏情况，且平均时间往往与最坏情况一样差。

增长量级：将运行时间的表示式中的低阶项和最高阶项的常系数忽略

2.3 分治法

许多算法在结构上是递归的，即多次的调用自身以解决相干的若干子问题。

- 分解：将原问题分解为若干子问题，子问题是原问题的规模较小的实例。
- 解决：解决子问题，并递归地求解各子问题。子问题规模足够小时，直接求解。
- 合并：将子问题的解合并为原问题的解。

运行时间的递归式：
$$
T(n)=\left\{
\begin{array}{lcl}
\Theta(1) & & {若n\leq c}\\
aT(n/b)+D(n)+C(n) & & {其他}
\end{array} \right.
$$
注：

- 将原问题分解成a个子问题，每个子问题的规模是原来的1/b。
- 分解成子问题需要时间D(n)，合并子问题需要时间C(n)。
- 问题规模较小时，直接求解需要常量时间Θ(1)。

二分：


$$
对于数组A[p...r]，令q=\lfloor(p+r)\rfloor/2,\\
将其分解为A[p...q]和A[q+1...r],\\
则前者包含\lceil n/2\rceil个元素，后者包含\lfloor n/2\rfloor个元素。
$$

```c++
vector<int>& nums;
int l = 0, r = n-1;
while(l < r)
{
    int mid = (l + r) / 2;
    if(nums[mid] > nums[r])
    	l = mid + 1;
    else
    	r = mid;
}
//循环结束后，l=r，即为目标值
```



回溯法：

- 系统性（在解空间树中深度优先搜索）
- 跳跃性（每次进入解空间树的结点后，判断应该向子树继续深度搜索，还是向父结点回溯）

基本步骤：

1. 定义问题的解空间
2. 确定易于搜索的解空间组织结构（树、图）
3. 对解空间进行深度优先搜索（可通过约束、限界提高搜索效率）

两种常见的解空间树：

1. 子集树（0-1背包，叶节点2^n，遍历时间Ω(2^n)）
2. 排列树（TSP旅行商问题，叶节点n!，遍历时间Ω(n!)）

（题外话：图的BFS有点类似于树的先序遍历，可用递归/栈实现；DFS有点类似于树的层序遍历，用队列实现）