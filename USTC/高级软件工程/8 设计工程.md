# 8 设计工程

设计是将问题转化成解决方案，设计模型是对解决方案的的描述。

##### 概念设计

顾客语言描述、系统功能、需求相关、独立于实现。

确定软件系统的结构、各模块的功能以及相互间的联系接口。

##### 技术设计

程序员角度描述硬件、软件、数据结构、数据流。

确定每个模块的算法、数据结构、接口细节。

是编码的先导。

##### 模块化分解的设计方法

将系统分解成模块/组件，每个功能由一个模块执行，每个模块的I/O被明确定义。

##### 三种设计层次

体系结构：组件关联构成系统

代码设计：为每个组件详细说明算法和数据结构（实现）

执行设计：设计的最低级，包括内存分配、数据格式和位组合（运行）

##### 软件体系结构的风格

三个方面：组件（模块）、连接器（组件之间的联系）、组件（模块）组合的限制条件

设计风格：

- 管道和过滤器：更适合批处理，数据流关系表示明确
- 隐含调用（事件驱动）：某个组件宣告事件，其他组件处理事件。
  利用注册程序处理事件（发布者/订阅者模式）
- 分层：每层为它的外层提供服务，需求阶段定义多层抽象很
  困难。
- 解释器：读入字符串并转换成可以执行的代码（虚拟机）。

##### 重要的设计问题

- 模块性与抽象层次
- 协作设计
- 设计用户界面
- 并发
- 设计模式与复用

### 优秀设计的特征

- 组件独立性
  - Coupling耦合性
  - Cohesion内聚性
- 例外设计与处理
- 防错和容错
  - N版本程序设计法（表决器）
  - 恢复块计数

##### 组件独立性

含义：一个模块具有独立功能而且和其它模块之间没有过多的相互作用

意义：独立的模块容易开发；容易测试和维护；有效阻断错误传播（ Ripple effect“涟漪效应”）

度量标准：内聚和耦合

##### 耦合性

模块之间互连程度。

耦合强弱取决于：模块间接口的复杂程度、调用模块的方式。

（由强到弱）

- 内容耦合：直接操作另一个模块的数据、代码重叠（go to）
- 公共耦合：全局数据结构
- 控制耦合：参数传递的是表示控制信息的标记量
- 标记耦合：参数传递的是数据结构（最低要求）
- 数据耦合：参数传递的是一般类型的数据
- 非直接耦合：通过上级模块进行联系

##### 内聚性

模块内各成分结合的紧密程度。

“理想的模块仅仅做一件事”。

（由强到弱）

- 功能性内聚：一个功能一个模块
- 顺序内聚：一个成分的输出就是下一个成分的输入。（最低要求）
- 通讯内聚：使用同一输入数据，或产生同一输出数据。
- 过程内聚：成分按照顺序执行。
- 时间内聚：几个成分的执行时间一样或按顺序排列
- 逻辑内聚：块内任务在逻辑上相似或相同
- 偶然（巧合）内聚：把重复的代码集成到一个模块内

##### 启发式规则

（一种经验规律，对改进设计和提高软件质量具有重要的参考价值，但不要过分拘泥于这些规则）

- 提高模块独立性：高内聚、低耦合

- 设计规模适中的模块

- 深度、宽度、扇入、扇出适中：

  （将模块间关联看作“树”）

  - 深度：软件结构中控制的层数，树高
  - 宽度：软件结构中同一个层次上的模块总数的最大数
  - 扇出：一个模块直接控制（调用）的模块数目
  - 扇入：指直接控制（调用）该模块的模块数目，（扇入越大，复用性越好）
  - 整个系统结构（“树”）呈现“椭圆外型”

- 模块的作用域应该在控制域之内

  - 控制域：控制范围，模块本身以及所有下属模块（直接调用模块和间接调用模块）
  - 作用域：作用范围，是受该模块内一个判定影响（调用/修改数据）的所有模块，
  - 若作用域超出控制域则是不好的设计，两种改进方法：判定上移、在作用域但不在控制域的模块下移。

- 降低接口复杂性：

  - 少于go to（内容耦合），全局变量（公共耦合），传递数据结构->传数据（标记耦合->数据耦合）

- 设计单入口和单出口的模块

- 设计功能可以预测的模块

------

##### 设计评审

1. 同顾客与用户一起审查概念设计
2. 向开发人员展示技术设计
3. 程序员在实现之前获得对他们设计的反馈

# 面向对象的设计的主要工作

- 用例实现精化

- 体系结构设计

- 构件设计

- 用户界面设计

- 数据持久设计

- 迭代精化


##### 用例实现方案精化

1. 提取边界类、实体类和控制类

   - 边界类：界面控制，外部接口，环境隔离。（执行者与用例之间的一种通信连接对应一个边界类。）
   - 控制类：完成用例任务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。（一个用例通常对应一个控制类。）
   - 实体类：具有持久意义的信息项及其操作。

2. 构造交互图

   - 顺序图：主动执行者—边界类—控制类—实体类和辅助类—边界类—被动执行者

   - 协作图：控制类（中心）、主动执行者和用户界面的边界类（左上方）、外部接口和环境隔离层的边界类（右上方）、辅助类和实体类（左下、右下方）

3. 根据交互图精化类图

##### 软件体系结构

以构件为基本<u>元素</u>，以一定的<u>结构</u>来构建软件。（高层的结构建立在基础结构之上，更底层的代码粒度太细了，所以抽象到了构件）

主流软件体系结构：C/S模式，MVC模式，分层模式

MVC架构：

- 模型：包含核心功能和数据 （模型与视图是一对多）
- 视图：向用户显示信息
- 控制器：处理用户输入（视图与控制器一一对应）

变更-传播机制保证了模型和用户界面之间的一致性：一旦模型的数据发生了变化，模型需要通知所有相关的视图做出相应的变化（每个在表中登记的视图和控制器都会收到变更通知）。

##### 构件设计

构件设计内部设计就是详细设计。

- 在相对较低的抽象层次上详细地说明所有算法
- 精化每个构件的接口
- 定义构件级数据结构
- 评审每个构件并修正所有已发现的错误

##### 数据持久存储服务

目的：将软件系统中依赖于系统运行环境的数据存取部分与其他部分分离。

设计：定义数据格式、定义数据存取操作

实现：文件系统、关系数据库、面向对象数据库。

##### 精化设计模型

任务：（自顶向下）

1. 以顶层架构图为基础，精化目标软件系统的体系结构
2. 精化类之间的关系。
3. 精化类的属性和操作
4. 针对具有明显状态转换特征的类，设计状态图
5. 针对比较复杂的类方法，设计活动图

# 面向对象设计的原则工作

##### 类的设计原则

- SRP 单一职责原则：
  - 一个类应该有且只有一个改变的理由。即每个类只做一件事（违反时可将类分裂）
- OCP 开放封闭原则：
  - 对类的扩展开放，对修改封闭。（设计和开发时要提高抽象层次）
- LSP 里氏替换原则：
  - 子类型应该能代替掉其父类型，且代替后程序运行情况不会错乱。（有继承关系的地方，子类型一定能代替父类型）
- DIP 依赖倒置原则：【OOD标志】
  - 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。（低层模块实现在高层模块中声明并被高层模块调用的接口）
  - 抽象不应该依赖于细节，细节应该依赖于抽象。（程序中所有的依赖关系都应该终止于抽象类或者接口）
- ISP 接口隔离原则
  - 不应该强迫客户依赖于它们不要的方法。接口属于客户，不属于它所在的类层次结构。避免这种耦合，分离接口。

##### 包的设计原则

包：比类更“大”的应用程序组织单元。

包的内聚性

- REP 重用发布等价原则
  - 重用的粒度就是发布的粒度（可重用的包应该由一组可重用的类组成）
- CCP 共同封闭原则
  - 包中的所有类对于同一类性质的变化应该是共同封闭的（一个包不应该包含多个引起变化的原因）
- CRP 共同重用原则
  - 如果重用了包中的一个类，那么就重用包中的所有类。（相互之间没有紧密联系的类不应该放在同一个包中）

包的耦合性

- ADP 无环依赖原则：在包的依赖图中，不允许存在环。（修正方法：依赖倒置，都依赖于新的接口包）
- SDP 稳定依赖原则：朝着稳定的方向进行依赖。（修正方法：依赖倒置，都依赖于新的接口包）
- SAP 稳定抽象原则：包的抽象程度应该和其稳定程度一致。（越稳定的包应该越抽象，可扩展性好）







2 71

3 42

4 200

5 56

6 56=

7 83=

8 130=

uml 91



# UML

[UML类图关系（泛化 、继承、实现、依赖、关联、聚合、组合）](https://www.cnblogs.com/meishibiexuejava/p/8551061.html)

