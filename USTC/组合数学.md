# 图论



途径：若干连续边的序列

迹：没有边重复的途径

路径：没有顶点重复的途径

圈：闭的路径

一条迹可以划分为一条路径+若干个圈。



欧拉闭迹：经过图中所有边的闭迹。（充要：每个顶点度数都为偶数）

欧拉开迹：经过图中所有边的开迹。（充要：每个顶点度数都为偶数，除了首尾结点是奇数）

哈密顿圈：经过图中所有顶点的圈。（NP hard）

- 存在桥就一定不含哈密顿圈
- Ore性质：不相邻结点的度 deg(x)+deg(y) ≥ n
- 每个顶点度数都大于至少为n/2

哈密顿路径：经过图中所有顶点的路径。（不相邻结点的度deg(x)+deg(y) ≥ n-1）

二分图：图中所有圈的长度都是偶数。

Qn（n维立方）：是二分图，好像必有哈密顿圈。



## 生成树

### 构造生成树的一般算法

（小树长成大树）

1. 对于连通图 G(V,E) ，将顶点分为两部分，已经在生成树中的（记为U）和还未在生成树中的（V-U）；
2. U一开始只包含根结点；
3. 每次选择一条边，使得边的两个端点分别在U和V-U中，连接该边，即把一个树外顶点加入到U中。

### 策略

对于第3步，采用不同的选边策略，可以得到不同的算法：

- **BFS**：按发现顺序给顶点标序号bf(x)，每次选边选择具有最小bf(x)的树内顶点

  （性质：T中点到根结点的距离 = G中点到根结点的距离）

- **DFS**：按发现顺序给顶点标序号df(x)，每次选边选择具有最大df(x)的树内顶点

- **Dijkstra**：单源最短路径，每个顶点记录到根结点的距离D(x)，每次选择**距离根结点最近**的树外顶点y（即 D(x)+c{x,y} 最小的边{x,y}），然后更新y的邻接点到根结点的距离D(x)。

  （Dijkstra是一种带权的BFS，具有类似的性质（dist in T = dist in G））

- **Prim**：最小生成树，每次选择**距离生成树最近**的点y，加入到树中，更新y的邻接点到生成树的距离D。



**Kruskal**：

最小生成树，贪心算法，与上述算法不同，采用连接子树构成大树的思路。

先将图的n个顶点作为n个连通分量，每次选择一条权最小、且不构成圈的边，连接。每次连边，连通分量数目-1。

实现细节：

1. 先把边按权排序
2. 判断是否产生圈的方法：在同一连通分量内连边会产生圈，可用不相交集合标识连通分量。

