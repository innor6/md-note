1.两数之和

input：给定一个不含重复元素的整数序列，给定一个整数target

output：从序列中找出两个数，使之和等于target，给出它们的index

（给定序列有且只有一个解）

思路：

1. 遍历序列，将整数加入到哈希表中；
2. 每次读入一个数的同时，根据给定的和，推算出所需的另一个数，在哈希表中查找是否存在该数。



14.最长公共前缀

input：一组字符串`vector<string> &`

output：所有字符串的公共前缀，没有则返回""

思路：

1. 令ret = strs[0]；
2. 遍历容器，每次选取一个字符串与ret比较，获取与ret的公共前缀，截断ret；
3. 遍历结束后返回ret。

特殊情况：

1. 输入的strs为空引用的情形。

优化：

1. 检查ret.size() == 0时退出循环
3. 还有一种思路是，将所有字符串按字典序排序，直接比较第一个和最后一个字符串的公共前缀即可。



15.三数之和

input：给定一个整数数组nums。

output：从nums中取三个数，使得三数之和等于0。

（找出所有满足条件的不重复三元组）

思路：

1. 先将数组按升序排序；
2. 遍历数组，即先确定“第一个数”：
   1. 优化：当“第一个数”大于0时，一定无解，直接结束遍历；
   2. 当取到重复的“第一个数”时，结果会重复，跳过该数；
3. 双指针法，扫描“第一个数”右侧的序列：先分别指向头尾，计算三数之和sum，移动指针向中间靠拢，直至左右指针重合、错位：
   1. 若sum==0，加入到结果集，移动左右指针；
   2. 若sum>0，移动右指针；
   3. 若sum<0，移动左指针；
   4. 移动指针时，若遇到重复值，则应跳过；

特殊情形：

1. 空输入&较小的输入：输入序列中的元素个数小于3时，可能访问越界
3. 越界：取“第一个数”时，index范围为`[0,n-2)`
4. 越界：移动指针时，左右指针不得超出范围（更严格的：不得错位`l<r`）



16.最接近的三数之和

input：整数数组nums，整数target

output：nums中最接近target的三数之和

（假设输入一定有唯一解）

思路：

1. 同上一题，先排序
2. 遍历数组，选取“第一个数”
   1. 跳过重复的数
3. 双指针法，从“第一个数”的右侧序列的头尾开始，计算三数之和sum，记录sum与target差值，更新最接近的解，两指针向中间靠拢，直至错位：
   1. 若sum==target，返回结果，结束程序；
   2. 若sum>target，移动右指针；
   3. 若sum<target，移动左指针；
   4. 移动指针时，跳过重复的数；

特殊情形：

1. 初始值：ret的初始值可以赋值为数组中的任意三数之和
2. 绝对值：差值计算时，需要使用绝对值，才能比较差值间的大小
3. 越界：取“第一个数”时，index范围为`[0,n-2)`
4. 越界：移动指针时，左右指针不得超出范围（不得错位）



17.电话按键的字母组合

input：数字2-9的一个序列，每个数字对应了几个英文字母

output：列出数字所能代表的字母的所有组合

思路：

1. 迭代，先将前n个数字对应的字母进行组合，然后将结果与下一个字母进行组合；
2. 数组vec保存每个数字对应的字母，数组ret保存前n个数字的组合结果；
3. 二重循环，获取第n次迭代结果的每一个字符串，获取第n+1个数字对应的每一个字母，将将它们组合，加入到一个临时数组temp中；
4. 每次迭代结束前，交换temp和ret，本次迭代结束时自动销毁temp。

特殊情形：

1. 空输入：返回空结果；
2. 初始值：迭代开始前，先向ret中放入一个空字符串。



18.两数相除

input：被除数dividend、除数divisor

output：商quotient

（整数除法，向零取整）

思路：

